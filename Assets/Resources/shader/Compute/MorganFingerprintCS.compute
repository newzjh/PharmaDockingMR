// MorganFingerprintCS.compute - 512位Count型Morgan指纹
#pragma kernel CSGenerateMorgan

// 原子数据结构（与C#结构体对齐）
struct AtomData {
    float3 position;   // 原子坐标
    int atomicNum;     // 原子序数
    int charge;        // 电荷
    int hybridization; // 杂化态
    int degree;        // 成键数
    int molId;         // 所属分子ID
};

// Morgan指纹输出结构（修改为512位）
struct MorganFP {
    uint counts[512]; // 核心修改：从1024→512位Count指纹
};

// 常量缓冲区：全局参数（修改fpLength为512）
cbuffer GlobalParams : register(b0) {
    int batchSize;     // 批量分子数
    int radius;        // Morgan半径（固定2）
    int fpLength;      // 指纹长度（512）
};

// 结构化缓冲区：输入原子数据
StructuredBuffer<AtomData> atomBuffer : register(t0);
// 结构化缓冲区：输出Morgan指纹（512位）
RWStructuredBuffer<MorganFP> fpBuffer : register(u0);

// 哈希函数：原子环境→512位指纹位（核心修改：取模512）
uint HashAtomEnv(int atomicNum, int charge, int neighborNum, int radius) {
    uint hash = atomicNum * 1000 + charge * 100 + neighborNum * 10 + radius;
    hash = hash ^ (hash << 13);
    hash = hash * 0x5bd1e995;
    hash = hash ^ (hash >> 15);
    return hash % fpLength; // 取模512，匹配新指纹长度
}

[numthreads(64, 1, 1)] // 工作组大小：64线程（GPU warp对齐）
void CSGenerateMorgan(uint3 dispatchThreadID : SV_DispatchThreadID) {
    int molId = dispatchThreadID.x;
    if (molId >= batchSize) return; // 超出批量范围则退出

    // 初始化当前分子的512位指纹
    for (int i = 0; i < fpLength; i++) { // fpLength=512
        fpBuffer[molId].counts[i] = 0;
    }

    // 遍历当前分子的所有原子
    int atomCount = 0;
    for (int i = 0; i < atomBuffer.Length; i++) {
        if (atomBuffer[i].molId == molId) {
            atomCount++;
            AtomData atom = atomBuffer[i];

            // 计算半径2内的原子环境（简化版：统计邻域原子数）
            int neighborNum = 0;
            for (int j = 0; j < atomBuffer.Length; j++) {
                if (atomBuffer[j].molId == molId && i != j) {
                    float dist = distance(atom.position, atomBuffer[j].position);
                    if (dist < 2.0) { // 半径2的邻域
                        neighborNum++;
                    }
                }
            }

            // 哈希映射到512位指纹位，计数累加
            uint fpIdx = HashAtomEnv(atom.atomicNum, atom.charge, neighborNum, radius);
            InterlockedAdd(fpBuffer[molId].counts[fpIdx], 1); // 原子累加避免竞争
        }
    }
}