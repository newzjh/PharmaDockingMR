#pragma kernel CSGenerateBallMesh
#pragma enable_d3d11_debug_symbols

#include "AtomCommon.hlsl"


// C#传递的参数
int batchSize;
int sphereSegments;
float bondLength;
float baseRadius;
int topK;



// 输入：SMILES Buffer
Texture2D<float4> smilesInputTexture;
StructuredBuffer<int> smilesInputBuffer;
// 输出：Mesh数据（顶点、法线、颜色）
RWStructuredBuffer<float3> meshDataOutput_vertex;
RWStructuredBuffer<float3> meshDataOutput_normal;
RWStructuredBuffer<float4> meshDataOutput_color;
// 输出：每个分子的原子数
RWStructuredBuffer<int> atomCountOutput;




// 生成球冠顶点与法线
void GenerateSphereCap(float3 center, float radius, float4 color, int atomIndex, int segments, inout int meshDataOffset)
{
    float thetaStep = 3.1415926f / segments; // 纬度步长（0~π/2，半球）
    float phiStep = 2 * 3.1415926f / segments; // 经度步长

    for(int y = 0; y <= segments; y++)
    {
        float theta = y * thetaStep;
        float sinTheta = sin(theta);
        float cosTheta = cos(theta);

        for(int x = 0; x <= segments; x++)
        {
            float phi = x * phiStep;
            float sinPhi = sin(phi);
            float cosPhi = cos(phi);

            // 球冠顶点坐标
            float3 vertex = float3(
                radius * sinTheta * cosPhi,
                radius * cosTheta,
                radius * sinTheta * sinPhi
            ) + center;

            // 法线（归一化）
            float3 normal = normalize(vertex - center);

            // 写入Buffer
            meshDataOutput_vertex[meshDataOffset] = vertex;
            meshDataOutput_normal[meshDataOffset] = normal;
            meshDataOutput_color[meshDataOffset] = color;

            meshDataOffset++;
        }
    }
}

[numthreads(32, 1, 1)]
void CSGenerateBallMesh(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if(molIdx >= batchSize) return;

    // 1. 读取当前分子的SMILES
    int smilesChars[SMILES_MAX_LENGTH];
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
    {
        //smilesChars[i] = smilesInputBuffer[molIdx * SMILES_MAX_LENGTH + i];
        float r = smilesInputTexture[int2(i, molIdx)].r;
        smilesChars[i] = (int) (r * 255.0f);
    }

    // 2. 解析SMILES
    int atomTypes[MAX_ATOM_COUNT];
    int atomCount;
    ParseSMILES(smilesChars, atomTypes, atomCount);
    atomCountOutput[molIdx] = atomCount;

    // 仅处理Top-K分子（简化版：假设前topK个为筛选后的分子）
    //if(molIdx >= topK) return;
    if(atomCount <= 1) return;

    // 3. 计算原子位置（简单链式排列）
    float3 atomPositions [MAX_ATOM_COUNT];
    for(int a = 0; a < atomCount; a++)
    {
        atomPositions[a] = float3(a * bondLength, 0, 0);
    }

    // 4. 生成每个原子的球冠Mesh
    int verticesPerAtom = (sphereSegments + 1) * (sphereSegments + 1);
    int meshDataOffset = molIdx * MAX_ATOM_COUNT * verticesPerAtom;

    for(int a = 0; a < atomCount; a++)
    {
        int type = atomTypes[a];
        float radius = GetAtomRadius(type);
        float4 color = GetAtomColor(type);
        GenerateSphereCap(atomPositions[a], radius, color, a, sphereSegments, meshDataOffset);
    }
}