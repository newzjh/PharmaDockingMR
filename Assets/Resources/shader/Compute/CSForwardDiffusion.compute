#pragma kernel CSForwardDiffusion
#pragma enable_d3d11_debug_symbols
#define MAX_ATOM_COUNT 50 // 分子最大原子数
#define SMILES_MAX_LENGTH 256
#define FP_SIZE 512
#define MAX_RING_COUNT 10 // 最大环数量
#define MAX_BRANCH_DEPTH 3 // 最大支链深度

// 原子类型常量定义（替代枚举，HLSL兼容）
#define ATOM_C 0
#define ATOM_c 1
#define ATOM_N 2
#define ATOM_n 3
#define ATOM_O 4
#define ATOM_o 5
#define ATOM_S 6
#define ATOM_s 7
#define ATOM_P 8
#define ATOM_p 9
#define ATOM_F 10
#define ATOM_Cl 11
#define ATOM_Br 12
#define ATOM_I 13
#define ATOM_H 14
#define ATOM_B 15
#define ATOM_Si 16
#define ATOM_As 17
#define ATOM_Se 18
#define ATOM_unknown 19

// 键类型常量定义（替代枚举，HLSL兼容）
#define BOND_Single 0
#define BOND_Double 1
#define BOND_Triple 2
#define BOND_Aromatic 3
#define BOND_unknown 4

// 通用扩散参数（适配任意大分子）
int batchSize;
int batchOffset;
int timesteps;
float heatmapWeight;
int maxAtoms;
float minFeatureScore;
int heatmapSize; // 热力图尺寸（兼容不同分辨率）

// 输入资源
Texture2D<float4> proteinHeatmap; // 通用大分子热力图
Texture3D<float4> proteinHeatmap3D; // 通用大分子热力图

// 输入Buffer
StructuredBuffer<float> betaBuffer;
StructuredBuffer<float> alphaCumprodBuffer;
float4 atomWeightBuffer; // 原子类型权重（扩展支持更多原子）
float4 activeCenterBuffer; // 大分子活性中心

// 输出Buffer
RWStructuredBuffer<int> smilesOutputBuffer;
RWTexture2D<float4> smilesOutputTexture;
RWStructuredBuffer<float> matchScoreDebugBuffer;

// 环标记结构
struct RingMarker {
    int atomIndex; // 环连接的原子索引
    int ringNumber; // 环编号（1-9, 0表示未使用）
};

// 哈希函数（生成随机数）
uint Hash(uint2 seed)
{
    seed = uint2(seed.x ^ seed.y * 16807, seed.y ^ seed.x * 48271);
    return seed.x * 2654435769 + seed.y * 1234567;
}

// 随机数生成（0-1）
float Random(uint2 seed)
{
    return frac(Hash(seed) * 0.00000000023283064365386962890625);
}

// 随机数生成（指定范围）
float RandomRange(uint2 seed, float min, float max)
{
    return min + Random(seed) * (max - min);
}

// 随机整数生成（指定范围）
int RandomInt(uint2 seed, int min, int max)
{
    return min + (int)(Random(seed) * (max - min + 1));
}

// 通用特征约束函数（基于大分子热力图）
float GetProteinFeatureConstraint(int totalMolIdx, float3 atomPos, float3 activeCenter)
{
    // 将原子坐标映射到热力图UV（适配任意热力图尺寸）
    //float2 uv = float2(
    //    (atomPos.x - activeCenter.x + heatmapSize * 0.5f) / heatmapSize,
    //    (atomPos.z - activeCenter.z + heatmapSize * 0.5f) / heatmapSize
    //);
    //uv = saturate(uv); // 限制UV在0-1范围内

    //// 采样热力图4通道特征（原子类型/电荷/疏水性/氢键）
    //float4 heatmapFeat = proteinHeatmap.SampleLevel(pointSampler, uv, 0);
    
    int2 uv2 = int2(atomPos.xz - activeCenter.xz + heatmapSize * 0.5f);
    uv2 = clamp(uv2, 0, int2(heatmapSize-1, heatmapSize-1));
    float4 heatmapFeat = proteinHeatmap.Load(int3(uv2, 0));
    
    // 加权求和得到特征匹配分数
    float featureScore = dot(heatmapFeat, float4(0.3f, 0.2f, 0.3f, 0.2f));
    return featureScore * heatmapWeight;
}

// 通用特征约束函数（3D版本）
float GetProteinFeatureConstraint3D(int totalMolIdx, float3 atomPos, float3 activeCenter)
{
    // 将原子坐标映射到热力图UV（适配任意热力图尺寸）
    //float2 uv = float2(
    //    (atomPos.x - activeCenter.x + heatmapSize * 0.5f) / heatmapSize,
    //    (atomPos.z - activeCenter.z + heatmapSize * 0.5f) / heatmapSize
    //);
    //uv = saturate(uv); // 限制UV在0-1范围内

    //// 采样热力图4通道特征（原子类型/电荷/疏水性/氢键）
    //float4 heatmapFeat = proteinHeatmap.SampleLevel(pointSampler, uv, 0);
    
    int3 uv3 = int3(atomPos - activeCenter + heatmapSize * 0.5f);
    uv3 = clamp(uv3, 0, int3(heatmapSize - 1, heatmapSize - 1, heatmapSize - 1));
    float4 heatmapFeat = proteinHeatmap3D.Load(int4(uv3, 0));
    
    // 加权求和得到特征匹配分数（调整权重适配更多原子类型）
    float featureScore = dot(heatmapFeat, float4(0.25f, 0.25f, 0.25f, 0.25f));
    return featureScore * heatmapWeight;
}

// 原子类型转SMILES字符（支持所有常见原子）
void AtomTypeToSMILES(int atomType, out int chars[3])
{
    // 初始化为空字符（0）
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    
    switch(atomType)
    {
        case ATOM_C: chars[0] = 'C'; break;
        case ATOM_c: chars[0] = 'c'; break;
        case ATOM_N: chars[0] = 'N'; break;
        case ATOM_n: chars[0] = 'n'; break;
        case ATOM_O: chars[0] = 'O'; break;
        case ATOM_o: chars[0] = 'o'; break;
        case ATOM_S: chars[0] = 'S'; break;
        case ATOM_s: chars[0] = 's'; break;
        case ATOM_P: chars[0] = 'P'; break;
        case ATOM_p: chars[0] = 'p'; break;
        case ATOM_F: chars[0] = 'F'; break;
        case ATOM_Cl: chars[0] = 'C'; chars[1] = 'l'; break;
        case ATOM_Br: chars[0] = 'B'; chars[1] = 'r'; break;
        case ATOM_I: chars[0] = 'I'; break;
        case ATOM_H: chars[0] = 'H'; break;
        case ATOM_B: chars[0] = 'B'; break;
        case ATOM_Si: chars[0] = 'S'; chars[1] = 'i'; break;
        case ATOM_As: chars[0] = 'A'; chars[1] = 's'; break;
        case ATOM_Se: chars[0] = 'S'; chars[1] = 'e'; break;
        default: chars[0] = 'X'; break;
    }
}

// 键类型转SMILES字符
int BondTypeToSMILES(int bondType)
{
    switch(bondType)
    {
        case BOND_Single: return '-';
        case BOND_Double: return '=';
        case BOND_Triple: return '#';
        case BOND_Aromatic: return ':';
        default: return '-';
    }
}

// 生成电荷标记（支持正负电荷）
void GenerateCharge(int charge, out int chars[3])
{
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    
    if (charge == 0) return;
    
    if (charge > 0)
    {
        chars[0] = '+';
        if (charge > 1)
        {
            chars[1] = '0' + charge;
        }
    }
    else
    {
        chars[0] = '-';
        if (charge < -1)
        {
            chars[1] = '0' - charge;
        }
    }
}

// 检查是否形成环结构
bool CheckRingFormation(float3 pos1, float3 pos2, float threshold)
{
    return distance(pos1, pos2) < threshold;
}

// 补充：原子最大价键定义（基于化学规则）
#define MAX_VALENCE_C 4
#define MAX_VALENCE_N 3
#define MAX_VALENCE_O 2
#define MAX_VALENCE_S 6
#define MAX_VALENCE_F 1
#define MAX_VALENCE_Cl 1
#define MAX_VALENCE_Br 1
#define MAX_VALENCE_I 1
#define MAX_VALENCE_H 1
#define MAX_VALENCE_B 3
#define MAX_VALENCE_Si 4
#define MAX_VALENCE_As 3
#define MAX_VALENCE_Se 2

// 补充：获取原子最大价键
int GetMaxValence(int atomType)
{
    switch(atomType)
    {
        case ATOM_C: case ATOM_c: case ATOM_Si: return MAX_VALENCE_C;
        case ATOM_N: case ATOM_n: case ATOM_As: return MAX_VALENCE_N;
        case ATOM_O: case ATOM_o: case ATOM_Se: return MAX_VALENCE_O;
        case ATOM_S: case ATOM_s: return MAX_VALENCE_S;
        case ATOM_F: case ATOM_Cl: case ATOM_Br: case ATOM_I: return 1;
        case ATOM_H: return MAX_VALENCE_H;
        case ATOM_B: return MAX_VALENCE_B;
        default: return 4; // 未知原子默认4价
    }
}

// 补充：计算键类型对应的键级（用于价键校验）
int GetBondOrder(int bondType)
{
    switch(bondType)
    {
        case BOND_Single: return 1;
        case BOND_Double: return 2;
        case BOND_Triple: return 3;
        case BOND_Aromatic: return 1.5; // 芳香键按1.5价计算
        default: return 1;
    }
}

// 修复后的SMILES编码函数（支持完整语法+化学规则约束）
void EncodeSMILES(int molIdx, int atomCount, in int atomTypes[MAX_ATOM_COUNT], 
                 in float3 atomPositions[MAX_ATOM_COUNT], in int bondTypes[MAX_ATOM_COUNT],
                 in int charges[MAX_ATOM_COUNT], out int smilesChars[SMILES_MAX_LENGTH])
{
    // 初始化SMILES缓冲区（0表示空字符）
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
    {
        smilesChars[i] = 0;
    }
    
    int charIdx = 0;
    RingMarker ringMarkers[MAX_RING_COUNT]; // 存储环的起点标记（原子索引+环编号）
    int ringCount = 0;
    int branchStack[MAX_BRANCH_DEPTH]; // 支链栈：存储支链结束的原子索引
    int branchDepth = 0;
    float currentValence[MAX_ATOM_COUNT]; // 跟踪每个原子已使用的价键数
    bool ringNumberUsed[MAX_RING_COUNT + 1]; // 标记环编号是否已使用（1-9）
    
    // -------------- 第一步：处理第一个原子（主链起点）--------------
    if (atomCount == 0) return;
    int firstAtomType = atomTypes[0];
    int firstAtomMaxValence = GetMaxValence(firstAtomType);
    
    // 处理第一个原子的类型字符
    int atomChars[3];
    AtomTypeToSMILES(firstAtomType, atomChars);
    for (int i = 0; i < 3 && atomChars[i] != 0 && charIdx < SMILES_MAX_LENGTH - 2; i++)
    {
        smilesChars[charIdx++] = atomChars[i];
    }
    
    // 处理第一个原子的电荷（修正：结合原子类型限制电荷范围）
    int firstCharge = charges[0];
    // 电荷约束：氢最多+1，氧最多+2/-2，碳最多+1/-1等
    switch(firstAtomType)
    {
        case ATOM_H: firstCharge = clamp(firstCharge, -1, 1); break;
        case ATOM_F: case ATOM_Cl: case ATOM_Br: case ATOM_I: firstCharge = clamp(firstCharge, -1, 1); break;
        case ATOM_O: case ATOM_o: firstCharge = clamp(firstCharge, -2, 2); break;
        default: firstCharge = clamp(firstCharge, -2, 2);break;
    }
    if (firstCharge != 0 && charIdx < SMILES_MAX_LENGTH - 2)
    {
        int chargeChars[3];
        GenerateCharge(firstCharge, chargeChars);
        for (int i = 0; i < 3 && chargeChars[i] != 0 && charIdx < SMILES_MAX_LENGTH - 2; i++)
        {
            smilesChars[charIdx++] = chargeChars[i];
        }
    }
    
    // 第一个原子初始价键：未连接任何键，故为0
    currentValence[0] = 0;
    
    // -------------- 第二步：处理后续原子（主链+支链+环）--------------
    for (int i = 1; i < atomCount; i++)
    {
        if (charIdx >= SMILES_MAX_LENGTH - 2) break; // 预留1个位置给结束符
        
        // 1. 结束已完成的支链（栈不为空且当前原子索引超过支链结束索引）
        while (branchDepth > 0 && i > branchStack[branchDepth - 1])
        {
            smilesChars[charIdx++] = ')';
            branchDepth--;
            if (charIdx >= SMILES_MAX_LENGTH - 2) break;
        }
        if (charIdx >= SMILES_MAX_LENGTH - 2) break;
        
        // 2. 处理当前原子与前一个原子的化学键（核心：价键校验）
        int prevAtomIdx = i - 1;
        int currentBondType = bondTypes[i];
        int currentBondOrder = GetBondOrder(currentBondType);
        int currentAtomType = atomTypes[i];
        int currentAtomMaxValence = GetMaxValence(currentAtomType);
        int prevAtomMaxValence = GetMaxValence(atomTypes[prevAtomIdx]);
        
        // 价键校验：确保前后原子的价键不超标
        if (currentValence[prevAtomIdx] + currentBondOrder > prevAtomMaxValence ||
            currentValence[i] + currentBondOrder > currentAtomMaxValence)
        {
            // 价键超标时，降级为单键
            currentBondType = BOND_Single;
            currentBondOrder = 1;
        }
        
        // 写入键符号（修正：单键默认省略，仅显式写入非单键）
        int bondChar = BondTypeToSMILES(currentBondType);
        if (currentBondType != BOND_Single)
        {
            smilesChars[charIdx++] = bondChar;
            if (charIdx >= SMILES_MAX_LENGTH - 2) break;
        }
        
        // 3. 随机生成支链（修正：仅在当前原子价键有剩余时生成）
        if (Random(uint2(molIdx + i, i)) < 0.3f && branchDepth < MAX_BRANCH_DEPTH && 
            i < atomCount - 2 && currentValence[i] + 1 <= currentAtomMaxValence)
        {
            smilesChars[charIdx++] = '(';
            branchStack[branchDepth++] = i + RandomInt(uint2(i, molIdx), 1, 2); // 支链长度限制为1-2个原子
            if (charIdx >= SMILES_MAX_LENGTH - 2) break;
        }
        
        // 4. 写入当前原子类型字符
        AtomTypeToSMILES(currentAtomType, atomChars);
        for (int j = 0; j < 3 && atomChars[j] != 0 && charIdx < SMILES_MAX_LENGTH - 2; j++)
        {
            smilesChars[charIdx++] = atomChars[j];
        }
        if (charIdx >= SMILES_MAX_LENGTH - 2) break;
        
        // 5. 处理当前原子的电荷（同第一步的电荷约束）
        int currentCharge = charges[i];
        switch(currentAtomType)
        {
            case ATOM_H: currentCharge = clamp(currentCharge, -1, 1); break;
            case ATOM_F: case ATOM_Cl: case ATOM_Br: case ATOM_I: currentCharge = clamp(currentCharge, -1, 1); break;
            case ATOM_O: case ATOM_o: currentCharge = clamp(currentCharge, -2, 2); break;
            default: currentCharge = clamp(currentCharge, -2, 2); break;
        }
        if (currentCharge != 0 && charIdx < SMILES_MAX_LENGTH - 2)
        {
            int chargeChars[3];
            GenerateCharge(currentCharge, chargeChars);
            for (int j = 0; j < 3 && chargeChars[j] != 0 && charIdx < SMILES_MAX_LENGTH - 2; j++)
            {
                smilesChars[charIdx++] = chargeChars[j];
            }
        }
        if (charIdx >= SMILES_MAX_LENGTH - 2) break;
        
        // 6. 处理环结构（修正：强制环编号成对，且价键校验）
        bool ringFormed = false;
        for (int j = 0; j < i - 1; j++) // 仅与前面已处理的原子形成环
        {
            if (CheckRingFormation(atomPositions[i], atomPositions[j], 1.8f) && 
                ringCount < MAX_RING_COUNT && charIdx < SMILES_MAX_LENGTH - 2)
            {
                // 检查j原子是否已有环起点标记
                int existingRingNum = -1;
                for (int k = 0; k < ringCount; k++)
                {
                    if (ringMarkers[k].atomIndex == j)
                    {
                        existingRingNum = ringMarkers[k].ringNumber;
                        break;
                    }
                }
                
                if (existingRingNum != -1)
                {
                    // 已有环起点：写入环编号（终点），完成配对
                    smilesChars[charIdx++] = '0' + existingRingNum;
                    // 校验环键的价键
                    int ringBondOrder = GetBondOrder(BOND_Single); // 环键默认单键
                    if (currentValence[j] + ringBondOrder <= prevAtomMaxValence &&
                        currentValence[i] + ringBondOrder <= currentAtomMaxValence)
                    {
                        currentValence[j] += ringBondOrder;
                        currentValence[i] += ringBondOrder;
                    }
                    ringFormed = true;
                    break;
                }
                else
                {
                    // 无环起点：创建新环标记（起点）
                    int newRingNum = -1;
                    for (int k = 1; k <= MAX_RING_COUNT; k++)
                    {
                        if (!ringNumberUsed[k])
                        {
                            newRingNum = k;
                            ringNumberUsed[k] = true;
                            break;
                        }
                    }
                    if (newRingNum != -1)
                    {
                        smilesChars[charIdx++] = '0' + newRingNum;
                        ringMarkers[ringCount].atomIndex = i;
                        ringMarkers[ringCount].ringNumber = newRingNum;
                        ringCount++;
                        ringFormed = true;
                        break;
                    }
                }
            }
        }
        
        // 7. 更新当前原子与前一个原子的价键数
        currentValence[prevAtomIdx] += currentBondOrder;
        currentValence[i] += currentBondOrder;
        
        // 8. 芳香键处理（修正：仅芳香环中添加，且不与其他键冲突）
        if ((currentAtomType == ATOM_c || currentAtomType == ATOM_n || 
             currentAtomType == ATOM_o || currentAtomType == ATOM_s) && 
            !ringFormed && currentBondType != BOND_Double && currentBondType != BOND_Triple)
        {
            if (Random(uint2(i, molIdx + i)) < 0.4f && charIdx < SMILES_MAX_LENGTH - 2)
            {
                smilesChars[charIdx++] = ':';
            }
        }
    }
    
    // -------------- 第三步：清理未闭合的结构 --------------
    // 关闭所有未结束的支链
    while (branchDepth > 0 && charIdx < SMILES_MAX_LENGTH - 2)
    {
        smilesChars[charIdx++] = ')';
        branchDepth--;
    }
    
    // -------------- 第四步：确保SMILES合法结束 --------------
    // 移除末尾可能残留的键符号（避免以键符号结尾）
    if (charIdx > 0)
    {
        int lastChar = smilesChars[charIdx - 1];
        if (lastChar == '-' || lastChar == '=' || lastChar == '#' || lastChar == ':')
        {
            charIdx--;
        }
    }
    
    // 以空字符结尾（SMILES标准）
    smilesChars[charIdx] = 0;
}

[numthreads(64, 1, 1)]
void CSForwardDiffusion(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if (molIdx >= batchSize)
        return;
    
    int totalMolIdx = molIdx + batchOffset;
    float3 activeCenter = activeCenterBuffer.xyz;
    float4 atomWeights = atomWeightBuffer;
    atomWeights = normalize(atomWeights);
    
    // 扩展原子权重数组（支持19种常见SMILES原子）
    float extendedAtomWeights[19] =
    {
        atomWeights.x * 1.2f, // ATOM_C
        atomWeights.x * 1.0f, // ATOM_c
        atomWeights.y * 1.1f, // ATOM_N
        atomWeights.y * 0.9f, // ATOM_n
        atomWeights.z * 1.0f, // ATOM_O
        atomWeights.z * 0.8f, // ATOM_o
        atomWeights.w * 0.7f, // ATOM_S
        atomWeights.w * 0.6f, // ATOM_s
        0.3f, // ATOM_P
        0.2f, // ATOM_p
        0.4f, // ATOM_F
        0.3f, // ATOM_Cl
        0.2f, // ATOM_Br
        0.1f, // ATOM_I
        0.5f, // ATOM_H
        0.2f, // ATOM_B
        0.1f, // ATOM_Si
        0.05f, // ATOM_As
        0.05f // ATOM_Se
    };
    
    // 初始化分子参数
    int atomCount = (int) lerp(5, maxAtoms, Random(uint2(molIdx, 0)));
    int atomTypes[MAX_ATOM_COUNT]; // 改为int数组存储原子类型常量
    float3 atomPositions[MAX_ATOM_COUNT];
    int bondTypes[MAX_ATOM_COUNT]; // 改为int数组存储键类型常量
    int charges[MAX_ATOM_COUNT];
    float totalFeatureScore = 0.0f;
    
    // 初始化匹配分数Debug Buffer
    for (int a = 0; a < MAX_ATOM_COUNT; a++)
    {
        matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = 0.0f;
    }
    
    // 前向扩散主循环
    for (int t = 0; t < timesteps; t++)
    {
        float alphaCumprod = alphaCumprodBuffer[t];
        float beta = betaBuffer[t];
        
        for (int a = 0; a < atomCount; a++)
        {
            if (t == 0)
            {
                // 初始化原子位置（基于活性中心）
                atomPositions[a] = activeCenter + float3(
                    RandomRange(uint2(totalMolIdx, a), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(a, totalMolIdx), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(totalMolIdx + a, a), -heatmapSize * 0.4f, heatmapSize * 0.4f)
                );
                
                // 随机选择原子类型（基于扩展权重）
                float rand = Random(uint2(totalMolIdx + a, t));
                float weightSum = 0.0f;
                for (int type = 0; type < 19; type++)
                {
                    weightSum += extendedAtomWeights[type];
                    if (rand < weightSum)
                    {
                        atomTypes[a] = type; // 存储原子类型常量
                        break;
                    }
                }
                
                // 初始化键类型（第一个原子无键）
                if (a == 0)
                {
                    bondTypes[a] = BOND_Single;
                }
                else
                {
                    // 随机选择键类型（0-BOND_unknown）
                    int bondRand = RandomInt(uint2(a, t), 0, 5);
                    bondTypes[a] = bondRand;
                }
                
                // 初始化电荷（-2到+2之间随机）
                charges[a] = RandomInt(uint2(a + t, totalMolIdx), -2, 2);
                // 降低电荷出现概率（70%概率为0电荷）
                if (Random(uint2(a, t)) > 0.3f)
                {
                    charges[a] = 0;
                }
            }
            
            // 前向扩散：添加高斯噪声
            float3 noise = float3(
                RandomRange(uint2(totalMolIdx + a, t), -1.0f, 1.0f),
                RandomRange(uint2(a, totalMolIdx + t), -1.0f, 1.0f),
                RandomRange(uint2(totalMolIdx + a + t, a), -1.0f, 1.0f)
            );
            atomPositions[a] = sqrt(alphaCumprod) * atomPositions[a] + sqrt(1 - alphaCumprod) * noise;
            
            // 施加大分子热力图约束
            float featureScore = GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter);
            totalFeatureScore += featureScore;
            
            // 更新匹配分数
            if (featureScore > matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a])
            {
                matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = featureScore;
            }
            
            // 拉回活性中心（特征分数过低时）
            if (featureScore < minFeatureScore)
            {
                atomPositions[a] = lerp(atomPositions[a], activeCenter, 0.15f);
            }
        }
    }
    
    // 过滤无效分子
    float avgFeatureScore = totalFeatureScore / (atomCount * timesteps);
    if (avgFeatureScore < minFeatureScore)
    {
        return;
    }
    
    // 编码为完整SMILES字符串
    int smilesChars[SMILES_MAX_LENGTH];
    EncodeSMILES(molIdx, atomCount, atomTypes, atomPositions, bondTypes, charges, smilesChars);
    
    // 写入输出Buffer和Texture
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
    {
        int charVal = smilesChars[i];
        smilesOutputBuffer[molIdx * SMILES_MAX_LENGTH + i] = charVal;
        float r = (float) charVal / 255.0f;
        smilesOutputTexture[int2(i, molIdx)] = float4(r, 0, 0, 1);
    }
}