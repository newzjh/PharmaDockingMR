#pragma kernel CSGenerateBallMesh

#define MAX_ATOM_COUNT 50 // 分子最大原子数
#define smilesMaxLength 256
#define fpSize 512

// 原子类型枚举
#define AtomTypeC 0
#define AtomTypeO 1
#define AtomTypeN 2
#define AtomTypeS 3
#define AtomTypeUNKNOWN 4

// C#传递的参数
int batchSize;
//int smilesMaxLength;
int sphereSegments;
float bondLength;
float baseRadius;
int topK;



// 输入：SMILES Buffer
StructuredBuffer<int> smilesInputBuffer;
// 输出：Mesh数据（顶点、法线、颜色）
RWStructuredBuffer<float3> meshDataOutput_vertex;
RWStructuredBuffer<float3> meshDataOutput_normal;
RWStructuredBuffer<float4> meshDataOutput_color;
// 输出：每个分子的原子数
RWStructuredBuffer<int> atomCountOutput;

// 原子半径与颜色映射（基于Cpk配色）
float GetAtomRadius(int type)
{
    switch(type)
    {
        case AtomTypeC: return baseRadius * 0.7f;
        case AtomTypeO: return baseRadius * 0.6f;
        case AtomTypeN: return baseRadius * 0.65f;
        case AtomTypeS: return baseRadius * 0.9f;
        default: return baseRadius * 0.5f;
    }
}

float4 GetAtomColor(int type)
{
    switch(type)
    {
        case AtomTypeC: return float4(0.2f, 0.2f, 0.2f, 1.0f); // 碳-灰色
        case AtomTypeO: return float4(1.0f, 0.0f, 0.0f, 1.0f); // 氧-红色
        case AtomTypeN: return float4(0.0f, 0.0f, 1.0f, 1.0f); // 氮-蓝色
        case AtomTypeS: return float4(1.0f, 1.0f, 0.0f, 1.0f); // 硫-黄色
        default: return float4(0.5f, 0.5f, 0.5f, 1.0f); // 未知-浅灰
    }
}

// 解析SMILES字符串，获取原子类型与数量
void ParseSMILES(in int smilesChars[smilesMaxLength], out int atomTypes[MAX_ATOM_COUNT], out int atomCount)
{
    atomCount = 0;
    //atomTypes = new AtomType[MAX_ATOM_COUNT];

    for(int i = 0; i < smilesMaxLength; i++)
    {
        int c = smilesChars[i];
        if(c == 0) break;
        if(c == '-' || c == '=' || c == '(' || c == ')') continue;

        switch(c)
        {
            case 'C': atomTypes[atomCount++] = AtomTypeC; break;
            case 'O': atomTypes[atomCount++] = AtomTypeO; break;
            case 'N': atomTypes[atomCount++] = AtomTypeN; break;
            case 'S': atomTypes[atomCount++] = AtomTypeS; break;
            default: atomTypes[atomCount++] = AtomTypeUNKNOWN; break;
        }

        if(atomCount >= MAX_ATOM_COUNT) break;
    }
}

// 生成球冠顶点与法线
void GenerateSphereCap(float3 center, float radius, float4 color, int atomIndex, int segments, inout int meshDataOffset)
{
    float thetaStep = 3.1415926f / segments; // 纬度步长（0~π/2，半球）
    float phiStep = 2 * 3.1415926f / segments; // 经度步长

    for(int y = 0; y <= segments; y++)
    {
        float theta = y * thetaStep;
        float sinTheta = sin(theta);
        float cosTheta = cos(theta);

        for(int x = 0; x <= segments; x++)
        {
            float phi = x * phiStep;
            float sinPhi = sin(phi);
            float cosPhi = cos(phi);

            // 球冠顶点坐标
            float3 vertex = float3(
                radius * sinTheta * cosPhi,
                radius * cosTheta,
                radius * sinTheta * sinPhi
            ) + center;

            // 法线（归一化）
            float3 normal = normalize(vertex - center);

            // 写入Buffer
            meshDataOutput_vertex[meshDataOffset] = vertex;
            meshDataOutput_normal[meshDataOffset] = normal;
            meshDataOutput_color[meshDataOffset] = color;

            meshDataOffset++;
        }
    }
}

[numthreads(32, 1, 1)]
void CSGenerateBallMesh(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if(molIdx >= batchSize) return;

    // 1. 读取当前分子的SMILES
    int smilesChars[smilesMaxLength];
    for(int i = 0; i < smilesMaxLength; i++)
    {
        smilesChars[i] = smilesInputBuffer[molIdx * smilesMaxLength + i];
    }

    // 2. 解析SMILES
    int atomTypes[MAX_ATOM_COUNT];
    int atomCount;
    ParseSMILES(smilesChars, atomTypes, atomCount);
    atomCountOutput[molIdx] = atomCount;

    // 仅处理Top-K分子（简化版：假设前topK个为筛选后的分子）
    if(molIdx >= topK) return;
    if(atomCount == 0) return;

    // 3. 计算原子位置（简单链式排列）
    float3 atomPositions [MAX_ATOM_COUNT];
    for(int a = 0; a < atomCount; a++)
    {
        atomPositions[a] = float3(a * bondLength, 0, 0);
    }

    // 4. 生成每个原子的球冠Mesh
    int verticesPerAtom = (sphereSegments + 1) * (sphereSegments + 1);
    int meshDataOffset = molIdx * atomCount * verticesPerAtom;

    for(int a = 0; a < atomCount; a++)
    {
        int type = atomTypes[a];
        float radius = GetAtomRadius(type);
        float4 color = GetAtomColor(type);
        GenerateSphereCap(atomPositions[a], radius, color, a, sphereSegments, meshDataOffset);
    }
}