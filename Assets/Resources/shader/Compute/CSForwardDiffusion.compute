#pragma kernel CSForwardDiffusion
#pragma enable_d3d11_debug_symbols
#define MAX_ATOM_COUNT 50 // 分子最大原子数
#define SMILES_MAX_LENGTH 256
#define FP_SIZE 512
#define MAX_RING_COUNT 10 // 最大环数量
#define MAX_BRANCH_DEPTH 3 // 最大支链深度

// 原子类型常量定义（替代枚举，HLSL兼容）
#define ATOM_C 0
#define ATOM_c 1
#define ATOM_N 2
#define ATOM_n 3
#define ATOM_O 4
#define ATOM_o 5
#define ATOM_S 6
#define ATOM_s 7
#define ATOM_P 8
#define ATOM_p 9
#define ATOM_F 10
#define ATOM_Cl 11
#define ATOM_Br 12
#define ATOM_I 13
#define ATOM_H 14
#define ATOM_B 15
#define ATOM_Si 16
#define ATOM_As 17
#define ATOM_Se 18
#define ATOM_unknown 19

// 键类型常量定义（替代枚举，HLSL兼容）
#define BOND_Single 0
#define BOND_Double 1
#define BOND_Triple 2
#define BOND_Aromatic 3
#define BOND_unknown 4

// 原子最大价键定义（严格遵循化学规则）
#define MAX_VALENCE_C 4
#define MAX_VALENCE_N 3
#define MAX_VALENCE_O 2
#define MAX_VALENCE_S 6
#define MAX_VALENCE_F 1
#define MAX_VALENCE_Cl 1
#define MAX_VALENCE_Br 1
#define MAX_VALENCE_I 1
#define MAX_VALENCE_H 1
#define MAX_VALENCE_B 3
#define MAX_VALENCE_Si 4
#define MAX_VALENCE_As 3
#define MAX_VALENCE_Se 2

// 通用扩散参数（适配任意大分子）
int batchSize;
int batchOffset;
int timesteps;
float heatmapWeight;
int maxAtoms;
float minFeatureScore;
int heatmapSize; // 热力图尺寸（兼容不同分辨率）

// 输入资源
Texture2D<float4> proteinHeatmap; // 通用大分子热力图
Texture3D<float4> proteinHeatmap3D; // 通用大分子热力图

// 输入Buffer
StructuredBuffer<float> betaBuffer;
StructuredBuffer<float> alphaCumprodBuffer;
float4 atomWeightBuffer; // 原子类型权重（扩展支持更多原子）
float4 activeCenterBuffer; // 大分子活性中心

// 输出Buffer
RWStructuredBuffer<int> smilesOutputBuffer;
RWTexture2D<float4> smilesOutputTexture;
RWStructuredBuffer<float> matchScoreDebugBuffer;

// 环标记结构
struct RingMarker {
    int atomIndex; // 环连接的原子索引
    int ringNumber; // 环编号（1-9, 0表示未使用）
};

// 哈希函数（生成随机数）
uint Hash(uint2 seed)
{
    seed = uint2(seed.x ^ seed.y * 16807, seed.y ^ seed.x * 48271);
    return seed.x * 2654435769 + seed.y * 1234567;
}

// 随机数生成（0-1）
float Random(uint2 seed)
{
    return frac(Hash(seed) * 0.00000000023283064365386962890625);
}

// 随机数生成（指定范围）
float RandomRange(uint2 seed, float min, float max)
{
    return min + Random(seed) * (max - min);
}

// 随机整数生成（指定范围）
int RandomInt(uint2 seed, int min, int max)
{
    return min + (int)(Random(seed) * (max - min + 1));
}

// 通用特征约束函数（基于大分子热力图）
float GetProteinFeatureConstraint(int totalMolIdx, float3 atomPos, float3 activeCenter)
{
    // 将原子坐标映射到热力图UV（适配任意热力图尺寸）
    //float2 uv = float2(
    //    (atomPos.x - activeCenter.x + heatmapSize * 0.5f) / heatmapSize,
    //    (atomPos.z - activeCenter.z + heatmapSize * 0.5f) / heatmapSize
    //);
    //uv = saturate(uv); // 限制UV在0-1范围内

    //// 采样热力图4通道特征（原子类型/电荷/疏水性/氢键）
    //float4 heatmapFeat = proteinHeatmap.SampleLevel(pointSampler, uv, 0);
    
    int2 uv2 = int2(atomPos.xz - activeCenter.xz + heatmapSize * 0.5f);
    uv2 = clamp(uv2, 0, int2(heatmapSize-1, heatmapSize-1));
    float4 heatmapFeat = proteinHeatmap.Load(int3(uv2, 0));
    
    // 加权求和得到特征匹配分数
    float featureScore = dot(heatmapFeat, float4(0.3f, 0.2f, 0.3f, 0.2f));
    return featureScore * heatmapWeight;
}

// 通用特征约束函数（3D版本）
float GetProteinFeatureConstraint3D(int totalMolIdx, float3 atomPos, float3 activeCenter)
{
    // 将原子坐标映射到热力图UV（适配任意热力图尺寸）
    //float2 uv = float2(
    //    (atomPos.x - activeCenter.x + heatmapSize * 0.5f) / heatmapSize,
    //    (atomPos.z - activeCenter.z + heatmapSize * 0.5f) / heatmapSize
    //);
    //uv = saturate(uv); // 限制UV在0-1范围内

    //// 采样热力图4通道特征（原子类型/电荷/疏水性/氢键）
    //float4 heatmapFeat = proteinHeatmap.SampleLevel(pointSampler, uv, 0);
    
    int3 uv3 = int3(atomPos - activeCenter + heatmapSize * 0.5f);
    uv3 = clamp(uv3, 0, int3(heatmapSize - 1, heatmapSize - 1, heatmapSize - 1));
    float4 heatmapFeat = proteinHeatmap3D.Load(int4(uv3, 0));
    
    // 加权求和得到特征匹配分数（调整权重适配更多原子类型）
    float featureScore = dot(heatmapFeat, float4(0.25f, 0.25f, 0.25f, 0.25f));
    return featureScore * heatmapWeight;
}

// 原子类型转SMILES字符（支持所有常见原子）
void AtomTypeToSMILES(int atomType, out int chars[3])
{
    // 初始化为空字符（0）
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    
    switch(atomType)
    {
        case ATOM_C: chars[0] = 'C'; break;
        case ATOM_c: chars[0] = 'c'; break;
        case ATOM_N: chars[0] = 'N'; break;
        case ATOM_n: chars[0] = 'n'; break;
        case ATOM_O: chars[0] = 'O'; break;
        case ATOM_o: chars[0] = 'o'; break;
        case ATOM_S: chars[0] = 'S'; break;
        case ATOM_s: chars[0] = 's'; break;
        case ATOM_P: chars[0] = 'P'; break;
        case ATOM_p: chars[0] = 'p'; break;
        case ATOM_F: chars[0] = 'F'; break;
        case ATOM_Cl: chars[0] = 'C'; chars[1] = 'l'; break;
        case ATOM_Br: chars[0] = 'B'; chars[1] = 'r'; break;
        case ATOM_I: chars[0] = 'I'; break;
        case ATOM_H: chars[0] = 'H'; break;
        case ATOM_B: chars[0] = 'B'; break;
        case ATOM_Si: chars[0] = 'S'; chars[1] = 'i'; break;
        case ATOM_As: chars[0] = 'A'; chars[1] = 's'; break;
        case ATOM_Se: chars[0] = 'S'; chars[1] = 'e'; break;
        default: chars[0] = 'X'; break;
    }
}

// 键类型转SMILES字符
int BondTypeToSMILES(int bondType)
{
    switch(bondType)
    {
        case BOND_Single: return '-';
        case BOND_Double: return '=';
        case BOND_Triple: return '#';
        case BOND_Aromatic: return ':';
        default: return '-';
    }
}

// 生成电荷标记（支持正负电荷）
void GenerateCharge(int charge, out int chars[3])
{
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    
    if (charge == 0) return;
    
    if (charge > 0)
    {
        chars[0] = '+';
        if (charge > 1)
        {
            chars[1] = '0' + charge;
        }
    }
    else
    {
        chars[0] = '-';
        if (charge < -1)
        {
            chars[1] = '0' - charge;
        }
    }
}

// 检查是否形成环结构
bool CheckRingFormation(float3 pos1, float3 pos2, float threshold)
{
    return distance(pos1, pos2) < threshold;
}

// 辅助函数：获取原子最大价键
int GetMaxValence(int atomType)
{
    switch (atomType)
    {
        case ATOM_C:
        case ATOM_c:
        case ATOM_Si:
            return MAX_VALENCE_C;
        case ATOM_N:
        case ATOM_n:
        case ATOM_As:
            return MAX_VALENCE_N;
        case ATOM_O:
        case ATOM_o:
        case ATOM_Se:
            return MAX_VALENCE_O;
        case ATOM_S:
        case ATOM_s:
            return MAX_VALENCE_S;
        case ATOM_F:
        case ATOM_Cl:
        case ATOM_Br:
        case ATOM_I:
            return 1;
        case ATOM_H:
            return MAX_VALENCE_H;
        case ATOM_B:
            return MAX_VALENCE_B;
        default:
            return 4; // 未知原子默认4价
    }
}
// 辅助函数：键类型转键级
float GetBondOrder(int bondType)
{
    switch (bondType)
    {
        case BOND_Single:
            return 1.0f;
        case BOND_Double:
            return 2.0f;
        case BOND_Triple:
            return 3.0f;
        case BOND_Aromatic:
            return 1.5f;
        default:
            return 1.0f;
    }
}
// 辅助函数：清理原子电荷（化学合理）
int SanitizeCharge(int atomType, int charge)
{
    switch (atomType)
    {
        case ATOM_H:
        case ATOM_F:
        case ATOM_Cl:
        case ATOM_Br:
        case ATOM_I:
            return clamp(charge, -1, 1);
        case ATOM_C:
        case ATOM_c:
            return clamp(charge, -1, 1);
        case ATOM_N:
        case ATOM_n:
            return clamp(charge, -1, 2);
        case ATOM_O:
        case ATOM_o:
            return clamp(charge, -2, 1);
        case ATOM_S:
        case ATOM_s:
            return clamp(charge, -2, 2);
        default:
            return clamp(charge, -1, 1);
    }
}
// 辅助函数：检查键与原子兼容性
bool IsBondCompatible(int atomType, int bondType)
{
    if (atomType == ATOM_H || atomType == ATOM_F || atomType == ATOM_Cl ||
        atomType == ATOM_Br || atomType == ATOM_I)
    {
        return bondType == BOND_Single;
    }
    if (atomType == ATOM_O || atomType == ATOM_o)
    {
        return bondType != BOND_Triple;
    }
    return true;
}
// 辅助函数：检查是否为键符号
bool IsBondChar(int c)
{
    return c == '-' || c == '=' || c == '#' || c == ':';
}
// 辅助函数：字符数组移位（替代memmove，HLSL兼容）
void ShiftCharsRight(int startIdx, int shiftCount, inout int chars[SMILES_MAX_LENGTH], int currentLen)
{
    int endIdx = currentLen + shiftCount - 1;
    if (endIdx >= SMILES_MAX_LENGTH - 1)
        return;
    // 从后往前移位，避免覆盖
    for (int i = currentLen - 1; i >= startIdx; i--)
    {
        chars[i + shiftCount] = chars[i];
    }
    // 清空移位后的原位置
    for (int i = startIdx; i < startIdx + shiftCount; i++)
    {
        chars[i] = 0;
    }
}
// 修复后的 EncodeSMILES() 函数（无memmove、无goto、全约束）
void EncodeSMILES(int molIdx, int atomCount, in int atomTypes[MAX_ATOM_COUNT],
                 in float3 atomPositions[MAX_ATOM_COUNT], in int bondTypes[MAX_ATOM_COUNT],
                 in int charges[MAX_ATOM_COUNT], out int smilesChars[SMILES_MAX_LENGTH])
{
    // 初始化缓冲区
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
        smilesChars[i] = 0;
    
    int charIdx = 0;
    RingMarker ringMarkers[MAX_RING_COUNT];
    int ringCount = 0;
    int branchStack[MAX_BRANCH_DEPTH];
    int branchDepth = 0;
    float currentValence[MAX_ATOM_COUNT];
    bool ringNumberUsed[MAX_RING_COUNT + 1];
    bool isAromaticRing[MAX_ATOM_COUNT];
    bool isBufferFull = false;
    
    // 边界检查
    if (atomCount == 0 || atomCount > MAX_ATOM_COUNT)
    {
        smilesChars[0] = 'C';
        smilesChars[1] = 0;
        return;
    }
    
    // 处理第一个原子（带电，如 [C-]）
    int firstAtomType = atomTypes[0];
    int firstSanitizedCharge = SanitizeCharge(firstAtomType, charges[0]);
    int firstAtomChars[3];
    AtomTypeToSMILES(firstAtomType, firstAtomChars);
    
    if (!isBufferFull)
    {
        // 写入原子类型（带电荷时包裹方括号）
        if (firstSanitizedCharge != 0)
        {
            int chargeChars[3];
            GenerateCharge(firstSanitizedCharge, chargeChars);
            int chargeLen = 0;
            while (chargeLen < 3 && chargeChars[chargeLen] != 0)
                chargeLen++;
            int shiftLen = 2 + chargeLen; // [ + 原子 + 电荷 + ]
            ShiftCharsRight(0, shiftLen, smilesChars, charIdx);
            
            smilesChars[0] = '[';
            int writeIdx = 1;
            for (int i = 0; i < 3 && firstAtomChars[i] != 0; i++)
                smilesChars[writeIdx++] = firstAtomChars[i];
            for (int i = 0; i < chargeLen; i++)
                smilesChars[writeIdx++] = chargeChars[i];
            smilesChars[writeIdx++] = ']';
            charIdx = writeIdx;
        }
        else
        {
            for (int i = 0; i < 3 && firstAtomChars[i] != 0 && charIdx < SMILES_MAX_LENGTH - 4; i++)
                smilesChars[charIdx++] = firstAtomChars[i];
        }
        isBufferFull = (charIdx >= SMILES_MAX_LENGTH - 4);
    }
    
    currentValence[0] = 0.0f;
    
    // 处理后续原子（主链+支链+键+电荷）
    for (int i = 1; i < atomCount && !isBufferFull; i++)
    {
        // 结束支链
        while (branchDepth > 0 && !isBufferFull)
        {
            if (i <= branchStack[branchDepth - 1])
                break;
            smilesChars[charIdx++] = ')';
            branchDepth--;
            isBufferFull = (charIdx >= SMILES_MAX_LENGTH - 4);
        }
        if (isBufferFull)
            break;
        
        // 处理化学键（价键校验+兼容性）
        int prevAtomIdx = i - 1;
        int rawBondType = bondTypes[i];
        int currentAtomType = atomTypes[i];
        int currentMaxValence = GetMaxValence(currentAtomType);
        int prevMaxValence = GetMaxValence(atomTypes[prevAtomIdx]);
        
        // 键兼容性校验
        if (!IsBondCompatible(currentAtomType, rawBondType) || !IsBondCompatible(atomTypes[prevAtomIdx], rawBondType))
            rawBondType = BOND_Single;
        
        // 价键超标处理
        float bondOrder = GetBondOrder(rawBondType);
        if (currentValence[prevAtomIdx] + bondOrder > prevMaxValence || currentValence[i] + bondOrder > currentMaxValence)
        {
            if (rawBondType == BOND_Triple)
                rawBondType = BOND_Double;
            else if (rawBondType == BOND_Double)
                rawBondType = BOND_Single;
            bondOrder = GetBondOrder(rawBondType);
            
            if (currentValence[prevAtomIdx] + bondOrder > prevMaxValence || currentValence[i] + bondOrder > currentMaxValence)
            {
                rawBondType = BOND_Single;
                bondOrder = 1.0f;
            }
        }
        
        // 写入键符号
        if (rawBondType != BOND_Single)
        {
            smilesChars[charIdx++] = BondTypeToSMILES(rawBondType);
            isBufferFull = (charIdx >= SMILES_MAX_LENGTH - 4);
            if (isBufferFull)
                break;
        }
        
        // 生成支链（20%概率，价键有剩余时）
        if (Random(uint2(molIdx + i, i)) < 0.2f && branchDepth < MAX_BRANCH_DEPTH &&
            i < atomCount - 2 && currentValence[i] + 1.0f <= currentMaxValence)
        {
            smilesChars[charIdx++] = '(';
            branchStack[branchDepth++] = i + RandomInt(uint2(i, molIdx), 1, 2);
            isBufferFull = (charIdx >= SMILES_MAX_LENGTH - 4);
            if (isBufferFull)
                break;
        }
        
        // 写入原子类型
        int currentAtomChars[3];
        AtomTypeToSMILES(currentAtomType, currentAtomChars);
        int atomLen = 0;
        while (atomLen < 3 && currentAtomChars[atomLen] != 0)
            atomLen++;
        for (int j = 0; j < atomLen && charIdx < SMILES_MAX_LENGTH - 4; j++)
            smilesChars[charIdx++] = currentAtomChars[j];
        isBufferFull = (charIdx >= SMILES_MAX_LENGTH - 4);
        if (isBufferFull)
            break;
        
        // 处理电荷（包裹方括号）
        int currentSanitizedCharge = SanitizeCharge(currentAtomType, charges[i]);
        if (currentSanitizedCharge != 0)
        {
            int chargeChars[3];
            GenerateCharge(currentSanitizedCharge, chargeChars);
            int chargeLen = 0;
            while (chargeLen < 3 && chargeChars[chargeLen] != 0)
                chargeLen++;
            int shiftLen = 2 + chargeLen;
            int atomStartIdx = charIdx - atomLen;
            ShiftCharsRight(atomStartIdx, shiftLen, smilesChars, charIdx);
            
            smilesChars[atomStartIdx] = '[';
            int chargeWriteIdx = atomStartIdx + atomLen;
            for (int j = 0; j < chargeLen; j++)
                smilesChars[chargeWriteIdx++] = chargeChars[j];
            smilesChars[chargeWriteIdx++] = ']';
            charIdx = chargeWriteIdx;
            isBufferFull = (charIdx >= SMILES_MAX_LENGTH - 2);
            if (isBufferFull)
                break;
        }
        
        // 处理环结构（成对标记，避免孤立）
        bool ringFormed = false;
        for (int j = 0; j < i - 1 && !ringFormed; j++)
        {
            if (CheckRingFormation(atomPositions[i], atomPositions[j], 1.8f) && ringCount < MAX_RING_COUNT && charIdx < SMILES_MAX_LENGTH - 2)
            {
                int existingRingNum = -1;
                for (int k = 0; k < ringCount; k++)
                    if (ringMarkers[k].atomIndex == j)
                        existingRingNum = ringMarkers[k].ringNumber;
                
                if (existingRingNum != -1)
                {
                    smilesChars[charIdx++] = '0' + existingRingNum;
                    float ringBondOrder = 1.0f;
                    if (currentValence[j] + ringBondOrder <= prevMaxValence && currentValence[i] + ringBondOrder <= currentMaxValence)
                    {
                        currentValence[j] += ringBondOrder;
                        currentValence[i] += ringBondOrder;
                    }
                    ringFormed = true;
                }
                else
                {
                    int newRingNum = -1;
                    for (int k = 1; k <= MAX_RING_COUNT; k++)
                        if (!ringNumberUsed[k])
                        {
                            newRingNum = k;
                            ringNumberUsed[k] = true;
                            break;
                        }
                    if (newRingNum != -1)
                    {
                        smilesChars[charIdx++] = '0' + newRingNum;
                        ringMarkers[ringCount].atomIndex = i;
                        ringMarkers[ringCount].ringNumber = newRingNum;
                        ringCount++;
                        ringFormed = true;
                    }
                }
            }
        }
        
        // 芳香键处理（仅芳香环，不冲突）
        if (isAromaticRing[i] && !ringFormed && rawBondType == BOND_Single && charIdx < SMILES_MAX_LENGTH - 2)
        {
            if (Random(uint2(i, molIdx + i)) < 0.3f)
                smilesChars[charIdx++] = ':';
        }
        
        // 更新价键
        currentValence[prevAtomIdx] += bondOrder;
        currentValence[i] += bondOrder;
    }
    
    // 清理：关闭支链、移除无效键符号、空字符结尾
    while (branchDepth > 0 && !isBufferFull && charIdx < SMILES_MAX_LENGTH - 2)
    {
        smilesChars[charIdx++] = ')';
        branchDepth--;
    }
    while (charIdx > 0 && IsBondChar(smilesChars[charIdx - 1]))
        charIdx--;
    smilesChars[charIdx] = 0;
    if (charIdx < 2)
    {
        smilesChars[0] = 'C';
        smilesChars[1] = 0;
    }
}

// 原 CSForwardDiffusion() 函数保留，仅需在原子初始化时优化：
// 1. 原子类型优先选择 ATOM_C/ATOM_c（确保碳链骨架）
// 2. 键类型降低三键概率（设为5%以下）
// 3. 电荷初始化时降低非0电荷概率（设为10%以下）

[numthreads(64, 1, 1)]
void CSForwardDiffusion(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if (molIdx >= batchSize)
        return;
    
    int totalMolIdx = molIdx + batchOffset;
    float3 activeCenter = activeCenterBuffer.xyz;
    float4 atomWeights = atomWeightBuffer;
    atomWeights = normalize(atomWeights);
    
    // 扩展原子权重数组（支持19种常见SMILES原子）
    float extendedAtomWeights[19] =
    {
        atomWeights.x * 1.2f, // ATOM_C
        atomWeights.x * 1.0f, // ATOM_c
        atomWeights.y * 1.1f, // ATOM_N
        atomWeights.y * 0.9f, // ATOM_n
        atomWeights.z * 1.0f, // ATOM_O
        atomWeights.z * 0.8f, // ATOM_o
        atomWeights.w * 0.7f, // ATOM_S
        atomWeights.w * 0.6f, // ATOM_s
        0.3f, // ATOM_P
        0.2f, // ATOM_p
        0.4f, // ATOM_F
        0.3f, // ATOM_Cl
        0.2f, // ATOM_Br
        0.1f, // ATOM_I
        0.5f, // ATOM_H
        0.2f, // ATOM_B
        0.1f, // ATOM_Si
        0.05f, // ATOM_As
        0.05f // ATOM_Se
    };
    
    // 初始化分子参数
    int atomCount = (int) lerp(5, maxAtoms, Random(uint2(molIdx, 0)));
    int atomTypes[MAX_ATOM_COUNT]; // 改为int数组存储原子类型常量
    float3 atomPositions[MAX_ATOM_COUNT];
    int bondTypes[MAX_ATOM_COUNT]; // 改为int数组存储键类型常量
    int charges[MAX_ATOM_COUNT];
    float totalFeatureScore = 0.0f;
    
    // 初始化匹配分数Debug Buffer
    for (int a = 0; a < MAX_ATOM_COUNT; a++)
    {
        matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = 0.0f;
    }
    
    // 前向扩散主循环
    for (int t = 0; t < timesteps; t++)
    {
        float alphaCumprod = alphaCumprodBuffer[t];
        float beta = betaBuffer[t];
        
        for (int a = 0; a < atomCount; a++)
        {
            if (t == 0)
            {
                // 初始化原子位置（基于活性中心）
                atomPositions[a] = activeCenter + float3(
                    RandomRange(uint2(totalMolIdx, a), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(a, totalMolIdx), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(totalMolIdx + a, a), -heatmapSize * 0.4f, heatmapSize * 0.4f)
                );
                
                // 随机选择原子类型（基于扩展权重）
                float rand = Random(uint2(totalMolIdx + a, t));
                float weightSum = 0.0f;
                for (int type = 0; type < 19; type++)
                {
                    weightSum += extendedAtomWeights[type];
                    if (rand < weightSum)
                    {
                        atomTypes[a] = type; // 存储原子类型常量
                        break;
                    }
                }
                
                // 初始化键类型（第一个原子无键）
                if (a == 0)
                {
                    bondTypes[a] = BOND_Single;
                }
                else
                {
                    // 核心修改1：降低三键概率至5%以下
                    float bondRandFloat = Random(uint2(a, t));
                    if (bondRandFloat < 0.05f)
                    {
                        bondTypes[a] = BOND_Triple; // 5%概率选择三键
                    }
                    else if (bondRandFloat < 0.1f)
                    {
                        bondTypes[a] = BOND_Aromatic; // 5%概率选择三键
                    }
                    else
                    {
                        // 剩余95%概率在单键、双键、芳香键、未知键中随机选择
                        int bondRand = RandomInt(uint2(a, t), 0, 1);
                        bondTypes[a] = bondRand;
                    }
                }
                
                // 初始化电荷
                // 核心修改2：降低非0电荷概率至10%以下
                float chargeRand = Random(uint2(a + t, totalMolIdx));
                if (chargeRand > 0.9f)
                {
                    // 10%概率生成非0电荷（-2到+2之间随机）
                    charges[a] = RandomInt(uint2(a + t, totalMolIdx), -2, 2);
                }
                else
                {
                    // 90%概率为0电荷
                    charges[a] = 0;
                }
            }
            
            // 前向扩散：添加高斯噪声
            float3 noise = float3(
                RandomRange(uint2(totalMolIdx + a, t), -1.0f, 1.0f),
                RandomRange(uint2(a, totalMolIdx + t), -1.0f, 1.0f),
                RandomRange(uint2(totalMolIdx + a + t, a), -1.0f, 1.0f)
            );
            atomPositions[a] = sqrt(alphaCumprod) * atomPositions[a] + sqrt(1 - alphaCumprod) * noise;
            
            // 施加大分子热力图约束
            float featureScore = GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter);
            totalFeatureScore += featureScore;
            
            // 更新匹配分数
            if (featureScore > matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a])
            {
                matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = featureScore;
            }
            
            // 拉回活性中心（特征分数过低时）
            if (featureScore < minFeatureScore)
            {
                atomPositions[a] = lerp(atomPositions[a], activeCenter, 0.15f);
            }
        }
    }
    
    // 过滤无效分子
    float avgFeatureScore = totalFeatureScore / (atomCount * timesteps);
    if (avgFeatureScore < minFeatureScore)
    {
        return;
    }
    
    // 编码为完整SMILES字符串
    int smilesChars[SMILES_MAX_LENGTH];
    EncodeSMILES(molIdx, atomCount, atomTypes, atomPositions, bondTypes, charges, smilesChars);
    
    // 写入输出Buffer和Texture
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
    {
        int charVal = smilesChars[i];
        smilesOutputBuffer[molIdx * SMILES_MAX_LENGTH + i] = charVal;
        float r = (float) charVal / 255.0f;
        smilesOutputTexture[int2(i, molIdx)] = float4(r, 0, 0, 1);
    }
}