#pragma kernel CSGenerateBallStickMesh
#pragma enable_d3d11_debug_symbols

#include "AtomCommon.hlsl"



// C#传递的全局参数
int batchSize;
int sphereSegments;
int cylinderSegments;
float bondLength;
float bondRadius;
int topK;

// 输入输出Buffer
Texture2D<float4> smilesInputTexture;
StructuredBuffer<int> smilesInputBuffer;
RWStructuredBuffer<float3> vertexOutputBuffer_position;
RWStructuredBuffer<float3> vertexOutputBuffer_normal;
RWStructuredBuffer<float4> vertexOutputBuffer_color;
RWStructuredBuffer<int> indexOutputBuffer;
RWStructuredBuffer<int> atomCountOutputBuffer;





// 生成原子球顶点/法线/颜色
void GenerateAtomSphere(float3 center, int type, int vertexOffset, int indexOffset, inout int vCount, inout int iCount)
{
    float radius = GetAtomRadius(type);
    float4 color = GetAtomColor(type);
    float thetaStep = 2 * 3.1415926f / sphereSegments;
    float phiStep = 3.1415926f / sphereSegments;

    int beginVCount = vCount;
    
    for (int y = 0; y <= sphereSegments; y++)
    {
        float phi = y * phiStep;
        float sinPhi = sin(phi);
        float cosPhi = cos(phi);

        for (int x = 0; x <= sphereSegments; x++)
        {
            float theta = x * thetaStep;
            float sinTheta = sin(theta);
            float cosTheta = cos(theta);

            // 球顶点坐标
            float3 pos = float3(
                radius * sinPhi * cosTheta,
                radius * sinPhi * sinTheta,
                radius * cosPhi
            ) + center;
            float3 normal = normalize(pos - center);

            // 写入顶点Buffer
            vertexOutputBuffer_position[vertexOffset + vCount] = pos;
            vertexOutputBuffer_normal[vertexOffset + vCount] = normal;
            vertexOutputBuffer_color[vertexOffset + vCount] = color;
            vCount++;
        }
    }

    // 生成球三角索引
    for (int y = 0; y < sphereSegments; y++)
    {
        for (int x = 0; x < sphereSegments; x++)
        {
            int v0 = x + y * (sphereSegments + 1);
            int v1 = v0 + 1;
            int v2 = v0 + (sphereSegments + 1);
            int v3 = v2 + 1;

            //indexOutputBuffer[indexOffset + iCount++] = v0 + vertexOffset;
            //indexOutputBuffer[indexOffset + iCount++] = v2 + vertexOffset;
            //indexOutputBuffer[indexOffset + iCount++] = v1 + vertexOffset;

            //indexOutputBuffer[indexOffset + iCount++] = v1 + vertexOffset;
            //indexOutputBuffer[indexOffset + iCount++] = v2 + vertexOffset;
            //indexOutputBuffer[indexOffset + iCount++] = v3 + vertexOffset;
            
            indexOutputBuffer[indexOffset + iCount++] = v0 + beginVCount;
            indexOutputBuffer[indexOffset + iCount++] = v2 + beginVCount;
            indexOutputBuffer[indexOffset + iCount++] = v1 + beginVCount;

            indexOutputBuffer[indexOffset + iCount++] = v1 + beginVCount;
            indexOutputBuffer[indexOffset + iCount++] = v2 + beginVCount;
            indexOutputBuffer[indexOffset + iCount++] = v3 + beginVCount;
        }
    }
}

// 生成化学键圆柱（棍）
void GenerateBondCylinder(float3 start, float3 end, float4 color, int vertexOffset, int indexOffset, inout int vCount, inout int iCount)
{
    float3 dir = normalize(end - start);
    float3 up = abs(dir.y) < 0.9f ? float3(0, 1, 0) : float3(1, 0, 0);
    float3 right = normalize(cross(dir, up));
    up = normalize(cross(right, dir));
    float length = distance(start, end);
    
    int beginVCount = vCount;

    // 生成圆柱两端顶点
    for (int i = 0; i <= cylinderSegments; i++)
    {
        float angle = i * 2 * 3.1415926f / cylinderSegments;
        float x = cos(angle);
        float z = sin(angle);

        float3 offset = right * x * bondRadius + up * z * bondRadius;
        vertexOutputBuffer_position[vertexOffset + vCount] = start + offset;
        vertexOutputBuffer_normal[vertexOffset + vCount] = normalize(offset);
        vertexOutputBuffer_color[vertexOffset + vCount] = color;
        vCount++;

        vertexOutputBuffer_position[vertexOffset + vCount] = end + offset;
        vertexOutputBuffer_normal[vertexOffset + vCount] = normalize(offset);
        vertexOutputBuffer_color[vertexOffset + vCount] = color;
        vCount++;
    }

    // 生成圆柱三角索引
    for (int i = 0; i < cylinderSegments; i++)
    {
        int v0 = i * 2;
        int v1 = v0 + 1;
        int v2 = (i + 1) * 2;
        int v3 = v2 + 1;

        indexOutputBuffer[indexOffset + iCount++] = v0 + beginVCount;
        indexOutputBuffer[indexOffset + iCount++] = v1 + beginVCount;
        indexOutputBuffer[indexOffset + iCount++] = v2 + beginVCount;

        indexOutputBuffer[indexOffset + iCount++] = v1 + beginVCount;
        indexOutputBuffer[indexOffset + iCount++] = v3 + beginVCount;
        indexOutputBuffer[indexOffset + iCount++] = v2 + beginVCount;
    }
}

[numthreads(32, 1, 1)]
void CSGenerateBallStickMesh(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if (molIdx >= batchSize)
        return;

    // 1. 读取SMILES字符串
    int smilesChars[smilesMaxLength];
    for (int i = 0; i < smilesMaxLength; i++)
    {
        //smilesChars[i] = smilesInputBuffer[molIdx * smilesMaxLength + i];
        float r = smilesInputTexture[int2(i, molIdx)].r;
        smilesChars[i] = (int) (r * 255.0f);
    }

    // 2. 解析SMILES
    int atomTypes[MAX_ATOM_COUNT];
    int atomCount = 0;
    ParseSMILES(smilesChars, atomTypes, atomCount);
    atomCountOutputBuffer[molIdx] = atomCount;

    //// 仅处理Top-K分子
    //if(molIdx >= topK || atomCount <= 1) return;
    if (atomCount <= 1)
        return;

    // 3. 计算原子位置（链式排列，沿X轴分布）
    float3 atomPositions[MAX_ATOM_COUNT];
    for (int a = 0; a < atomCount; a++)
    {
        atomPositions[a] = float3(a * bondLength, 0, 0);
    }

    // 4. 计算当前分子的Buffer偏移量
    int verticesPerAtom = (sphereSegments + 1) * (sphereSegments + 1);
    int verticesPerBond = 2 * (cylinderSegments + 1);
    int indicesPerAtom = sphereSegments * sphereSegments * 6;
    int indicesPerBond = cylinderSegments * 6;

    int totalVertices = MAX_ATOM_COUNT * verticesPerAtom + (MAX_ATOM_COUNT - 1) * verticesPerBond;
    int totalIndices = MAX_ATOM_COUNT * indicesPerAtom + (MAX_ATOM_COUNT - 1) * indicesPerBond;
    int vertexOffset = molIdx * totalVertices;
    int indexOffset = molIdx * totalIndices;

    int vCount = 0;
    int iCount = 0;

    // 5. 生成原子球
    for (int a = 0; a < atomCount; a++)
    {
        GenerateAtomSphere(atomPositions[a], atomTypes[a], vertexOffset, indexOffset, vCount, iCount);
    }
    
    //vertexOffset += MAX_ATOM_COUNT * verticesPerAtom;
    //indexOffset += MAX_ATOM_COUNT * indicesPerAtom;

    // 6. 生成化学键棍（取原子颜色均值）
    for (int b = 0; b < atomCount - 1; b++)
    {
        float4 color = (GetAtomColor(atomTypes[b]) + GetAtomColor(atomTypes[b + 1])) * 0.5f;
        GenerateBondCylinder(atomPositions[b], atomPositions[b + 1], color, vertexOffset, indexOffset, vCount, iCount);
    }
}