#pragma kernel CSForwardDiffusion
#pragma enable_d3d11_debug_symbols
#define MAX_ATOM_COUNT 50
#define SMILES_MAX_LENGTH 256
#define FP_SIZE 512
#define MAX_RING_COUNT 10
#define MAX_BRANCH_DEPTH 3

// 原子/键类型定义（原定义保留）
#define ATOM_C 0
#define ATOM_c 1
#define ATOM_N 2
#define ATOM_n 3
#define ATOM_O 4
#define ATOM_o 5
#define ATOM_S 6
#define ATOM_s 7
#define ATOM_P 8
#define ATOM_p 9
#define ATOM_F 10
#define ATOM_Cl 11
#define ATOM_Br 12
#define ATOM_I 13
#define ATOM_H 14
#define ATOM_B 15
#define ATOM_Si 16
#define ATOM_As 17
#define ATOM_Se 18
#define ATOM_unknown 19

#define BOND_Single 0
#define BOND_Double 1
#define BOND_Triple 2
#define BOND_Aromatic 3
#define BOND_unknown 4

// 原子最大价键定义
#define MAX_VALENCE_C 4
#define MAX_VALENCE_N 3
#define MAX_VALENCE_O 2
#define MAX_VALENCE_S 6
#define MAX_VALENCE_F 1
#define MAX_VALENCE_Cl 1
#define MAX_VALENCE_Br 1
#define MAX_VALENCE_I 1
#define MAX_VALENCE_H 1
#define MAX_VALENCE_B 3
#define MAX_VALENCE_Si 4
#define MAX_VALENCE_As 3
#define MAX_VALENCE_Se 2

// 通用参数（原定义保留）
int batchSize;
int batchOffset;
int timesteps;
float heatmapWeight; // 热力图约束权重（0~1，1为完全约束）
int maxAtoms;
float minFeatureScore;
int heatmapSize;

// 输入/输出资源（原定义保留）
Texture2D<float4> proteinHeatmap;
Texture3D<float4> proteinHeatmap3D;
StructuredBuffer<float> betaBuffer;
StructuredBuffer<float> alphaCumprodBuffer;
float4 atomWeightBuffer;
float4 activeCenterBuffer;
RWStructuredBuffer<int> smilesOutputBuffer;
RWTexture2D<float4> smilesOutputTexture;
RWStructuredBuffer<float> matchScoreDebugBuffer;

// 环标记结构（原定义保留）
struct RingMarker
{
    int atomIndex;
    int ringNumber;
};

// 工具函数（Hash、Random等，保留不变）
uint Hash(uint2 seed)
{
    seed = uint2(seed.x ^ seed.y * 16807, seed.y ^ seed.x * 48271);
    return seed.x * 2654435769 + seed.y * 1234567;
}
float Random(uint2 seed)
{
    return frac(Hash(seed) * 0.00000000023283064365386962890625);
}
float RandomRange(uint2 seed, float min, float max)
{
    return min + Random(seed) * (max - min);
}
int RandomInt(uint2 seed, int min, int max)
{
    return min + (int) (Random(seed) * (max - min + 1));
}

// 原子类型映射（直接使用r通道浮点值匹配原子类型ID）
int HeatmapRToAtomType(float rVal)
{
    // r通道为原子类型ID的浮点值，直接取整并约束范围
    int atomTypeID = (int) round(rVal);
    return clamp(atomTypeID, 0, 18); // 0~18对应ATOM_C到ATOM_Se
}

// 通用特征约束函数（基于大分子热力图）
float GetProteinFeatureConstraint(int totalMolIdx, float3 atomPos, float3 activeCenter,
                                out float atomTypeR, out float chargeG, out float hydrophobicB, out float hBondA)
{
    int2 uv2 = int2(atomPos.xz - activeCenter.xz + heatmapSize * 0.5f);
    uv2 = clamp(uv2, 0, int2(heatmapSize-1, heatmapSize-1));
    float4 heatmapFeat = proteinHeatmap.Load(int3(uv2, 0));
    
    // 直接提取原始通道值（无任何映射转换）
    atomTypeR = heatmapFeat.r * 10; // 原子类型ID（浮点值，如0.0=ATOM_C，1.0=ATOM_c）
    chargeG = heatmapFeat.g; // 电荷原始值（如-1.0、0.0、1.0）
    hydrophobicB = heatmapFeat.b; // 疏水性原始值（0~1）
    hBondA = heatmapFeat.a; // 氢键潜力原始值（0~1）    
    
    // 加权计算总特征分（保留各通道原始权重）
    float featureScore = (atomTypeR * 0.3f) + (abs(chargeG) * 0.2f) + (hydrophobicB * 0.3f) + (hBondA * 0.2f);
    return featureScore * heatmapWeight;
}

// 增强版特征约束函数（直接返回原始通道值，无映射）
float GetProteinFeatureConstraint3D(int totalMolIdx, float3 atomPos, float3 activeCenter,
                                   out float atomTypeR, out float chargeG, out float hydrophobicB, out float hBondA)
{
    int3 uv3 = int3(atomPos - activeCenter + heatmapSize * 0.5f);
    uv3 = clamp(uv3, 0, int3(heatmapSize - 1, heatmapSize - 1, heatmapSize - 1));
    float4 heatmapFeat = proteinHeatmap3D.Load(int4(uv3, 0));
    
    // 直接提取原始通道值（无任何映射转换）
    atomTypeR = heatmapFeat.r * 10; // 原子类型ID（浮点值，如0.0=ATOM_C，1.0=ATOM_c）
    chargeG = heatmapFeat.g; // 电荷原始值（如-1.0、0.0、1.0）
    hydrophobicB = heatmapFeat.b; // 疏水性原始值（0~1）
    hBondA = heatmapFeat.a; // 氢键潜力原始值（0~1）
    
    // 加权计算总特征分（保留各通道原始权重）
    float featureScore = (atomTypeR * 0.3f) + (abs(chargeG) * 0.2f) + (hydrophobicB * 0.3f) + (hBondA * 0.2f);
    return featureScore * heatmapWeight;
}

// 其余辅助函数（完整保留，无修改）
void AtomTypeToSMILES(int atomType, out int chars[3])
{
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    switch (atomType)
    {
        case ATOM_C:
            chars[0] = 'C';
            break;
        case ATOM_c:
            chars[0] = 'c';
            break;
        case ATOM_N:
            chars[0] = 'N';
            break;
        case ATOM_n:
            chars[0] = 'n';
            break;
        case ATOM_O:
            chars[0] = 'O';
            break;
        case ATOM_o:
            chars[0] = 'o';
            break;
        case ATOM_S:
            chars[0] = 'S';
            break;
        case ATOM_s:
            chars[0] = 's';
            break;
        case ATOM_P:
            chars[0] = 'P';
            break;
        case ATOM_p:
            chars[0] = 'p';
            break;
        case ATOM_F:
            chars[0] = 'F';
            break;
        case ATOM_Cl:
            chars[0] = 'C';
            chars[1] = 'l';
            break;
        case ATOM_Br:
            chars[0] = 'B';
            chars[1] = 'r';
            break;
        case ATOM_I:
            chars[0] = 'I';
            break;
        case ATOM_H:
            chars[0] = 'H';
            break;
        case ATOM_B:
            chars[0] = 'B';
            break;
        case ATOM_Si:
            chars[0] = 'S';
            chars[1] = 'i';
            break;
        case ATOM_As:
            chars[0] = 'A';
            chars[1] = 's';
            break;
        case ATOM_Se:
            chars[0] = 'S';
            chars[1] = 'e';
            break;
        default:
            chars[0] = 'X';
            break;
    }
}
int BondTypeToSMILES(int bondType)
{
    switch (bondType)
    {
        case BOND_Single:
            return '-';
        case BOND_Double:
            return '=';
        case BOND_Triple:
            return '#';
        case BOND_Aromatic:
            return ':';
        default:
            return '-';
    }
}
void GenerateCharge(int charge, out int chars[3])
{
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    if (charge == 0)
        return;
    if (charge > 0)
    {
        chars[0] = '+';
        if (charge > 1)
            chars[1] = '0' + charge;
    }
    else
    {
        chars[0] = '-';
        if (charge < -1)
            chars[1] = '0' - charge;
    }
}
bool CheckRingFormation(float3 pos1, float3 pos2, float threshold)
{
    return distance(pos1, pos2) < threshold;
}
int GetMaxValence(int atomType)
{
    switch (atomType)
    {
        case ATOM_C:
        case ATOM_c:
        case ATOM_Si:
            return MAX_VALENCE_C;
        case ATOM_N:
        case ATOM_n:
        case ATOM_As:
            return MAX_VALENCE_N;
        case ATOM_O:
        case ATOM_o:
        case ATOM_Se:
            return MAX_VALENCE_O;
        case ATOM_S:
        case ATOM_s:
            return MAX_VALENCE_S;
        case ATOM_F:
        case ATOM_Cl:
        case ATOM_Br:
        case ATOM_I:
            return 1;
        case ATOM_H:
            return MAX_VALENCE_H;
        case ATOM_B:
            return MAX_VALENCE_B;
        default:
            return 4;
    }
}
float GetBondOrder(int bondType)
{
    switch (bondType)
    {
        case BOND_Single:
            return 1.0f;
        case BOND_Double:
            return 2.0f;
        case BOND_Triple:
            return 3.0f;
        case BOND_Aromatic:
            return 1.5f;
        default:
            return 1.0f;
    }
}
int SanitizeCharge(int atomType, int charge)
{
    switch (atomType)
    {
        case ATOM_H:
        case ATOM_F:
        case ATOM_Cl:
        case ATOM_Br:
        case ATOM_I:
            return clamp(charge, -1, 1);
        case ATOM_C:
        case ATOM_c:
            return clamp(charge, -1, 1);
        case ATOM_N:
        case ATOM_n:
            return clamp(charge, -1, 2);
        case ATOM_O:
        case ATOM_o:
            return clamp(charge, -2, 1);
        case ATOM_S:
        case ATOM_s:
            return clamp(charge, -2, 2);
        default:
            return clamp(charge, -1, 1);
    }
}
bool IsBondCompatible(int atomType, int bondType)
{
    if (atomType == ATOM_H || atomType == ATOM_F || atomType == ATOM_Cl ||
        atomType == ATOM_Br || atomType == ATOM_I)
    {
        return bondType == BOND_Single;
    }
    if (atomType == ATOM_O || atomType == ATOM_o)
    {
        return bondType != BOND_Triple;
    }
    return true;
}
bool IsBondChar(int c)
{
    return c == '-' || c == '=' || c == '#' || c == ':';
}
void ShiftCharsRight(int startIdx, int shiftCount, inout int chars[SMILES_MAX_LENGTH], int currentLen)
{
    int endIdx = currentLen + shiftCount - 1;
    if (endIdx >= SMILES_MAX_LENGTH - 1)
        return;
    for (int i = currentLen - 1; i >= startIdx; i--)
    {
        chars[i + shiftCount] = chars[i];
    }
    for (int i = startIdx; i < startIdx + shiftCount; i++)
    {
        chars[i] = 0;
    }
}
void EncodeSMILES(int molIdx, int atomCount, in int atomTypes[MAX_ATOM_COUNT],
                 in float3 atomPositions[MAX_ATOM_COUNT], in int bondTypes[MAX_ATOM_COUNT],
                 in int charges[MAX_ATOM_COUNT], out int smilesChars[SMILES_MAX_LENGTH])
{
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
        smilesChars[i] = 0;
    
    int charIdx = 0;
    RingMarker ringMarkers[MAX_RING_COUNT];
    int ringCount = 0;
    int branchStack[MAX_BRANCH_DEPTH];
    int branchDepth = 0;
    float currentValence[MAX_ATOM_COUNT];
    bool ringNumberUsed[MAX_RING_COUNT + 1];
    bool isAromaticRing[MAX_ATOM_COUNT];
    bool isBufferFull = false;
    
    if (atomCount == 0 || atomCount > MAX_ATOM_COUNT)
    {
        smilesChars[0] = 'C';
        smilesChars[1] = 0;
        return;
    }
    
    // 处理第一个原子
    int firstAtomType = atomTypes[0];
    int firstSanitizedCharge = SanitizeCharge(firstAtomType, charges[0]);
    int firstAtomChars[3];
    AtomTypeToSMILES(firstAtomType, firstAtomChars);
    
    if (!isBufferFull)
    {
        for (int i = 0; i < 3 && firstAtomChars[i] != 0 && charIdx < SMILES_MAX_LENGTH - 4; i++)
        {
            smilesChars[charIdx++] = firstAtomChars[i];
        }
        if (charIdx >= SMILES_MAX_LENGTH - 4)
            isBufferFull = true;
    }
    
    if (!isBufferFull && firstSanitizedCharge != 0)
    {
        int chargeChars[3];
        GenerateCharge(firstSanitizedCharge, chargeChars);
        int chargeLen = 0;
        while (chargeLen < 3 && chargeChars[chargeLen] != 0)
            chargeLen++;
        int shiftLen = 2 + chargeLen;
        ShiftCharsRight(0, shiftLen, smilesChars, charIdx);
        
        smilesChars[0] = '[';
        int writeIdx = 1;
        for (int i = 0; i < 3 && firstAtomChars[i] != 0; i++)
            smilesChars[writeIdx++] = firstAtomChars[i];
        for (int i = 0; i < chargeLen; i++)
            smilesChars[writeIdx++] = chargeChars[i];
        smilesChars[writeIdx++] = ']';
        charIdx = writeIdx;
        if (charIdx >= SMILES_MAX_LENGTH - 2)
            isBufferFull = true;
    }
    
    currentValence[0] = 0.0f;
    
    // 处理后续原子
    for (int i = 1; i < atomCount && !isBufferFull; i++)
    {
        while (branchDepth > 0 && !isBufferFull)
        {
            if (i <= branchStack[branchDepth - 1])
                break;
            smilesChars[charIdx++] = ')';
            branchDepth--;
            if (charIdx >= SMILES_MAX_LENGTH - 4)
                isBufferFull = true;
        }
        if (isBufferFull)
            break;
        
        // 化学键处理（价键+兼容性校验）
        int prevAtomIdx = i - 1;
        int rawBondType = bondTypes[i];
        int currentAtomType = atomTypes[i];
        int currentMaxValence = GetMaxValence(currentAtomType);
        int prevMaxValence = GetMaxValence(atomTypes[prevAtomIdx]);
        
        if (!IsBondCompatible(currentAtomType, rawBondType) || !IsBondCompatible(atomTypes[prevAtomIdx], rawBondType))
            rawBondType = BOND_Single;
        
        float bondOrder = GetBondOrder(rawBondType);
        if (currentValence[prevAtomIdx] + bondOrder > prevMaxValence ||
            currentValence[i] + bondOrder > currentMaxValence)
        {
            if (rawBondType == BOND_Triple)
                rawBondType = BOND_Double;
            else if (rawBondType == BOND_Double)
                rawBondType = BOND_Single;
            bondOrder = GetBondOrder(rawBondType);
            
            if (currentValence[prevAtomIdx] + bondOrder > prevMaxValence ||
                currentValence[i] + bondOrder > currentMaxValence)
            {
                rawBondType = BOND_Single;
                bondOrder = 1.0f;
            }
        }
        
        if (rawBondType != BOND_Single)
        {
            smilesChars[charIdx++] = BondTypeToSMILES(rawBondType);
            if (charIdx >= SMILES_MAX_LENGTH - 4)
            {
                isBufferFull = true;
                break;
            }
        }
        
        // 支链生成（20%概率）
        if (Random(uint2(molIdx + i, i)) < 0.2f && branchDepth < MAX_BRANCH_DEPTH &&
            i < atomCount - 2 && currentValence[i] + 1.0f <= currentMaxValence)
        {
            smilesChars[charIdx++] = '(';
            branchStack[branchDepth++] = i + RandomInt(uint2(i, molIdx), 1, 2);
            if (charIdx >= SMILES_MAX_LENGTH - 4)
            {
                isBufferFull = true;
                break;
            }
        }
        
        // 原子类型写入
        int currentAtomChars[3];
        AtomTypeToSMILES(currentAtomType, currentAtomChars);
        int atomLen = 0;
        while (atomLen < 3 && currentAtomChars[atomLen] != 0)
            atomLen++;
        for (int j = 0; j < atomLen && charIdx < SMILES_MAX_LENGTH - 4; j++)
            smilesChars[charIdx++] = currentAtomChars[j];
        if (charIdx >= SMILES_MAX_LENGTH - 4)
        {
            isBufferFull = true;
            break;
        }
        
        // 电荷处理（带电荷包裹方括号）
        int currentSanitizedCharge = SanitizeCharge(currentAtomType, charges[i]);
        if (currentSanitizedCharge != 0)
        {
            int chargeChars[3];
            GenerateCharge(currentSanitizedCharge, chargeChars);
            int chargeLen = 0;
            while (chargeLen < 3 && chargeChars[chargeLen] != 0)
                chargeLen++;
            int shiftLen = 2 + chargeLen;
            int atomStartIdx = charIdx - atomLen;
            ShiftCharsRight(atomStartIdx, shiftLen, smilesChars, charIdx);
            
            smilesChars[atomStartIdx] = '[';
            int chargeWriteIdx = atomStartIdx + atomLen;
            for (int j = 0; j < chargeLen; j++)
                smilesChars[chargeWriteIdx++] = chargeChars[j];
            smilesChars[chargeWriteIdx++] = ']';
            charIdx = chargeWriteIdx;
            if (charIdx >= SMILES_MAX_LENGTH - 2)
            {
                isBufferFull = true;
                break;
            }
        }
        
        // 环结构处理（成对编号）
        bool ringFormed = false;
        for (int j = 0; j < i - 1 && !ringFormed; j++)
        {
            if (CheckRingFormation(atomPositions[i], atomPositions[j], 1.8f) &&
                ringCount < MAX_RING_COUNT && charIdx < SMILES_MAX_LENGTH - 2)
            {
                int existingRingNum = -1;
                for (int k = 0; k < ringCount; k++)
                {
                    if (ringMarkers[k].atomIndex == j)
                    {
                        existingRingNum = ringMarkers[k].ringNumber;
                        break;
                    }
                }
                
                if (existingRingNum != -1)
                {
                    smilesChars[charIdx++] = '0' + existingRingNum;
                    float ringBondOrder = 1.0f;
                    if (currentValence[j] + ringBondOrder <= prevMaxValence &&
                        currentValence[i] + ringBondOrder <= currentMaxValence)
                    {
                        currentValence[j] += ringBondOrder;
                        currentValence[i] += ringBondOrder;
                    }
                    if ((atomTypes[j] == ATOM_c || atomTypes[j] == ATOM_n || atomTypes[j] == ATOM_o || atomTypes[j] == ATOM_s) &&
                        (currentAtomType == ATOM_c || currentAtomType == ATOM_n || currentAtomType == ATOM_o || currentAtomType == ATOM_s))
                    {
                        isAromaticRing[j] = true;
                        isAromaticRing[i] = true;
                    }
                    ringFormed = true;
                    break;
                }
                else
                {
                    int newRingNum = -1;
                    for (int k = 1; k <= MAX_RING_COUNT; k++)
                    {
                        if (!ringNumberUsed[k])
                        {
                            newRingNum = k;
                            ringNumberUsed[k] = true;
                            break;
                        }
                    }
                    if (newRingNum != -1)
                    {
                        smilesChars[charIdx++] = '0' + newRingNum;
                        ringMarkers[ringCount].atomIndex = i;
                        ringMarkers[ringCount].ringNumber = newRingNum;
                        ringCount++;
                        ringFormed = true;
                        break;
                    }
                }
            }
        }
        
        // 芳香键处理（仅芳香环，不冲突）
        if (isAromaticRing[i] && !ringFormed && rawBondType == BOND_Single && charIdx < SMILES_MAX_LENGTH - 2)
        {
            if (Random(uint2(i, molIdx + i)) < 0.3f)
            {
                smilesChars[charIdx++] = ':';
                if (charIdx >= SMILES_MAX_LENGTH - 2)
                    isBufferFull = true;
            }
        }
        
        // 更新价键数
        currentValence[prevAtomIdx] += bondOrder;
        currentValence[i] += bondOrder;
    }
    
    // 清理与规范化
    while (branchDepth > 0 && !isBufferFull && charIdx < SMILES_MAX_LENGTH - 2)
    {
        smilesChars[charIdx++] = ')';
        branchDepth--;
    }
    while (charIdx > 0 && IsBondChar(smilesChars[charIdx - 1]))
        charIdx--;
    smilesChars[charIdx] = 0;
    if (charIdx < 2)
    {
        smilesChars[0] = 'C';
        smilesChars[1] = 0;
    }
}

// 核心修改：直接使用热力图原始浮点通道值约束的CSForwardDiffusion
[numthreads(64, 1, 1)]
void CSForwardDiffusion(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if (molIdx >= batchSize)
        return;
    
    int totalMolIdx = molIdx + batchOffset;
    float3 activeCenter = activeCenterBuffer.xyz;
    float4 atomWeights = atomWeightBuffer;
    atomWeights = normalize(atomWeights);
    
    // 初始化分子参数
    int atomCount = (int) lerp(10, maxAtoms, Random(uint2(molIdx, 0))); // 多环适配：最少10个原子
    int atomTypes[MAX_ATOM_COUNT];
    float3 atomPositions[MAX_ATOM_COUNT];
    int bondTypes[MAX_ATOM_COUNT];
    int charges[MAX_ATOM_COUNT];
    float totalFeatureScore = 0.0f;
    
    // 初始化Debug Buffer
    for (int a = 0; a < MAX_ATOM_COUNT; a++)
    {
        matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = 0.0f;
    }
    
    // 前向扩散主循环（全程使用热力图原始通道值约束）
    for (int t = 0; t < timesteps; t++)
    {
        float alphaCumprod = alphaCumprodBuffer[t];
        float beta = betaBuffer[t];
        
        for (int a = 0; a < atomCount; a++)
        {
            // 提取当前原子位置的热力图原始通道值
            float atomTypeR, chargeG, hydrophobicB, hBondA;
            
            if (t == 0)
            {
                // 初始位置：基于活性中心+小范围随机（贴近热力图有效区域）
                atomPositions[a] = activeCenter + float3(
                    RandomRange(uint2(totalMolIdx, a), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(a, totalMolIdx), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(totalMolIdx + a, a), -heatmapSize * 0.4f, heatmapSize * 0.4f)
                );
                
                // 第一步：直接使用r通道原始浮点值约束原子类型
                GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter,
                                            atomTypeR, chargeG, hydrophobicB, hBondA);
                atomTypes[a] = HeatmapRToAtomType(atomTypeR);
                
                // 第二步：直接使用g通道原始浮点值作为电荷（无映射）
                // 仅做化学合理性校验，不修改原始值
                int rawCharge = (int) round(chargeG);
                charges[a] = SanitizeCharge(atomTypes[a], rawCharge);
                
                // 第三步：初始化键类型（受氢键/疏水性原始值约束）
                if (a == 0)
                {
                    bondTypes[a] = BOND_Single;
                }
                else
                {
                    // 氢键潜力原始值>0.5：优先单键（利于形成氢键）
                    if (hBondA > 0.5f)
                    {
                        bondTypes[a] = BOND_Single;
                    }
                    // 疏水性原始值>0.7：优先芳香键/双键（疏水区域特征）
                    else if (hydrophobicB > 0.7f)
                    {
                        bondTypes[a] = Random(uint2(a, t)) < 0.5f ? BOND_Aromatic : BOND_Double;
                    }
                    // 三键概率≤5%（原约束保留）
                    else if (Random(uint2(a, t)) < 0.05f)
                    {
                        bondTypes[a] = BOND_Triple;
                    }
                    else
                    {
                        bondTypes[a] = BOND_Single;
                    }
                    // 键兼容性校验（立即修正）
                    if (!IsBondCompatible(atomTypes[a], bondTypes[a]))
                    {
                        bondTypes[a] = BOND_Single;
                    }
                }
            }
            else
            {
                // 扩散过程：噪声受热力图约束，避免偏离特征区域
                float3 noise = float3(
                    RandomRange(uint2(totalMolIdx + a, t), -1.0f, 1.0f),
                    RandomRange(uint2(a, totalMolIdx + t), -1.0f, 1.0f),
                    RandomRange(uint2(totalMolIdx + a + t, a), -1.0f, 1.0f)
                );
                
                // 基础扩散公式
                atomPositions[a] = sqrt(alphaCumprod) * atomPositions[a] + sqrt(1 - alphaCumprod) * noise;
                
                // 提取扩散后位置的热力图原始特征值
                float featureScore = GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter,
                                                                 atomTypeR, chargeG, hydrophobicB, hBondA);
                totalFeatureScore += featureScore;
                
                // 特征分过低：强制拉回活性中心+热力图高特征区域
                if (featureScore < minFeatureScore)
                {
                    atomPositions[a] = lerp(atomPositions[a], activeCenter, 0.2f);
                    // 拉回后重新提取热力图原始特征
                    featureScore = GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter,
                                                                 atomTypeR, chargeG, hydrophobicB, hBondA);
                }
                
                // 实时更新原子类型（直接使用r通道原始值）
                int newAtomType = HeatmapRToAtomType(atomTypeR);
                // 仅当原子类型变化不破坏价键时更新
                float currentBondOrder = GetBondOrder(bondTypes[a]);
                int currentMaxValence = GetMaxValence(atomTypes[a]);
                int newMaxValence = GetMaxValence(newAtomType);
                if (currentBondOrder <= newMaxValence)
                {
                    atomTypes[a] = newAtomType;
                }
                
                // 实时更新电荷（直接使用g通道原始值）
                int newCharge = (int) round(chargeG);
                charges[a] = SanitizeCharge(atomTypes[a], newCharge);
                
                // 实时更新键类型（受氢键/疏水性原始值动态约束）
                if (hBondA > 0.5f && !IsBondCompatible(atomTypes[a], bondTypes[a]))
                {
                    bondTypes[a] = BOND_Single;
                }
                else if (hydrophobicB > 0.7f && atomTypes[a] == ATOM_c)
                {
                    bondTypes[a] = BOND_Aromatic;
                }
                
                // 更新Debug Buffer
                if (featureScore > matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a])
                {
                    matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = featureScore;
                }
            }
        }
    }
    
    // 过滤无效分子（仅保留热力图特征分达标的分子）
    float avgFeatureScore = totalFeatureScore / (atomCount * timesteps);
    if (avgFeatureScore < minFeatureScore)
        return;
    
    // 编码为合规SMILES
    int smilesChars[SMILES_MAX_LENGTH];
    EncodeSMILES(molIdx, atomCount, atomTypes, atomPositions, bondTypes, charges, smilesChars);
    
    // 写入输出
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
    {
        int charVal = smilesChars[i];
        smilesOutputBuffer[molIdx * SMILES_MAX_LENGTH + i] = charVal;
        float r = (float) charVal / 255.0f;
        smilesOutputTexture[int2(i, molIdx)] = float4(r, 0, 0, 1);
    }
}