#pragma kernel CSForwardDiffusion
#pragma enable_d3d11_debug_symbols
#define MAX_ATOM_COUNT 50
#define SMILES_MAX_LENGTH 256
#define FP_SIZE 512
#define MAX_RING_COUNT 10
#define MAX_BRANCH_DEPTH 3
#define MAX_CONSECUTIVE_ATOMS 3 // 禁止连续相同原子超过3个

/******************************************************************************************
 * 版本修改记录（按时间顺序）：
 * v1.0 基础版本：实现基本的SMILES生成，包含原子/键类型定义、简单扩散逻辑
 * v2.0 热力图约束：适配热力图RGBA原始浮点通道，直接驱动原子类型/电荷/疏水性/氢键潜力
 * v3.0 合规性约束：增加环标记成对校验、价键强制合规、禁止连续原子重复、三键/非0电荷概率控制
 * v4.0 长碳链适配：优化原子数（≥15）、长碳链集中分布、支链生成逻辑适配多环结构
 * v5.0 杂原子优化：
 *      1. 强化N/O杂原子价键约束（O≤2、N≤3）
 *      2. 杂原子环优先分配1/2号环编号
 *      3. 禁止键符号与括号相邻，避免O:(CC)类非法组合
 *      4. 优化环闭合逻辑，优先闭合杂原子环
 * v6.0 编译修复（当前版本）：
 *      1. 修复EncodeSMILES中ringFormed变量先使用后声明的编译错误
 *      2. 优化变量声明顺序，确保所有变量先声明后使用
 *      3. 补充变量初始化，避免未初始化变量导致的逻辑错误
 ******************************************************************************************/

// 原子/键类型定义
#define ATOM_C 0
#define ATOM_c 1
#define ATOM_N 2
#define ATOM_n 3
#define ATOM_O 4
#define ATOM_o 5
#define ATOM_S 6
#define ATOM_s 7
#define ATOM_P 8
#define ATOM_p 9
#define ATOM_F 10
#define ATOM_Cl 11
#define ATOM_Br 12
#define ATOM_I 13
#define ATOM_H 14
#define ATOM_B 15
#define ATOM_Si 16
#define ATOM_As 17
#define ATOM_Se 18
#define ATOM_unknown 19

#define BOND_Single 0
#define BOND_Double 1
#define BOND_Triple 2
#define BOND_Aromatic 3
#define BOND_unknown 4

// 原子最大价键定义
#define MAX_VALENCE_C 4
#define MAX_VALENCE_N 3
#define MAX_VALENCE_O 2
#define MAX_VALENCE_S 6
#define MAX_VALENCE_F 1
#define MAX_VALENCE_Cl 1
#define MAX_VALENCE_Br 1
#define MAX_VALENCE_I 1
#define MAX_VALENCE_H 1
#define MAX_VALENCE_B 3
#define MAX_VALENCE_Si 4
#define MAX_VALENCE_As 3
#define MAX_VALENCE_Se 2

// 通用参数
int batchSize;
int batchOffset;
int timesteps;
float heatmapWeight; // 热力图约束权重（0~1）
int maxAtoms;
float minFeatureScore;
int heatmapSize;

// 输入/输出资源
Texture2D<float4> proteinHeatmap;
Texture3D<float4> proteinHeatmap3D;
StructuredBuffer<float> betaBuffer;
StructuredBuffer<float> alphaCumprodBuffer;
float4 atomWeightBuffer;
float4 activeCenterBuffer;
RWStructuredBuffer<int> smilesOutputBuffer;
RWTexture2D<float4> smilesOutputTexture;
RWStructuredBuffer<float> matchScoreDebugBuffer;

// 环标记结构
struct RingMarker
{
    int atomIndex;
    int ringNumber;
};

// 工具函数
uint Hash(uint2 seed)
{
    seed = uint2(seed.x ^ seed.y * 16807, seed.y ^ seed.x * 48271);
    return seed.x * 2654435769 + seed.y * 1234567;
}

float Random(uint2 seed)
{
    return frac(Hash(seed) * 0.00000000023283064365386962890625);
}

float RandomRange(uint2 seed, float min, float max)
{
    return min + Random(seed) * (max - min);
}

int RandomInt(uint2 seed, int min, int max)
{
    return min + (int) (Random(seed) * (max - min + 1));
}

// 原子类型映射（直接使用r通道浮点值匹配原子类型ID）
int HeatmapRToAtomType(float rVal)
{
    int atomTypeID = (int) round(rVal);
    return clamp(atomTypeID, 0, 18); // 0~18对应ATOM_C到ATOM_Se
}

// 检查环编号是否可用（仅允许成对出现）
bool IsRingNumberAvailable(int ringNum, in RingMarker ringMarkers[MAX_RING_COUNT], int ringCount)
{
    int count = 0;
    for (int k = 0; k < ringCount; k++)
    {
        if (ringMarkers[k].ringNumber == ringNum)
            count++;
    }
    return count < 2; // 每个环编号仅允许使用2次（起点+终点）
}

// 通用特征约束函数（基于大分子热力图）
float GetProteinFeatureConstraint(int totalMolIdx, float3 atomPos, float3 activeCenter,
                                out float atomTypeR, out float chargeG, out float hydrophobicB, out float hBondA)
{
    int2 uv2 = int2(atomPos.xz - activeCenter.xz + heatmapSize * 0.5f);
    uv2 = clamp(uv2, 0, int2(heatmapSize-1, heatmapSize-1));
    float4 heatmapFeat = proteinHeatmap.Load(int3(uv2, 0));
    
    // 直接提取原始通道值（无任何映射转换）
    atomTypeR = heatmapFeat.r * 10; // 原子类型ID（浮点值，如0.0=ATOM_C，1.0=ATOM_c）
    chargeG = heatmapFeat.g; // 电荷原始值（如-1.0、0.0、1.0）
    hydrophobicB = heatmapFeat.b; // 疏水性原始值（0~1）
    hBondA = heatmapFeat.a; // 氢键潜力原始值（0~1）    
    
    // 加权计算总特征分（保留各通道原始权重）
    float featureScore = (atomTypeR * 0.3f) + (abs(chargeG) * 0.2f) + (hydrophobicB * 0.3f) + (hBondA * 0.2f);
    return featureScore * heatmapWeight;
}

// 增强版特征约束函数（直接返回原始通道值）
float GetProteinFeatureConstraint3D(int totalMolIdx, float3 atomPos, float3 activeCenter,
                                   out float atomTypeR, out float chargeG, out float hydrophobicB, out float hBondA)
{
    int3 uv3 = int3(atomPos - activeCenter + heatmapSize * 0.5f);
    uv3 = clamp(uv3, 0, int3(heatmapSize - 1, heatmapSize - 1, heatmapSize - 1));
    float4 heatmapFeat = proteinHeatmap3D.Load(int4(uv3, 0));
    
    // 直接提取原始通道值
    atomTypeR = heatmapFeat.r * 10; // 原子类型ID（浮点值）
    chargeG = heatmapFeat.g; // 电荷原始值
    hydrophobicB = heatmapFeat.b; // 疏水性原始值（0~1）
    hBondA = heatmapFeat.a; // 氢键潜力原始值（0~1）
    
    // 加权计算总特征分
    float featureScore = (atomTypeR * 0.3f) + (abs(chargeG) * 0.2f) + (hydrophobicB * 0.3f) + (hBondA * 0.2f);
    return featureScore * heatmapWeight;
}

// 原子类型转SMILES字符
void AtomTypeToSMILES(int atomType, out int chars[3])
{
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    switch (atomType)
    {
        case ATOM_C:
            chars[0] = 'C';
            break;
        case ATOM_c:
            chars[0] = 'c';
            break;
        case ATOM_N:
            chars[0] = 'N';
            break;
        case ATOM_n:
            chars[0] = 'n';
            break;
        case ATOM_O:
            chars[0] = 'O';
            break;
        case ATOM_o:
            chars[0] = 'o';
            break;
        case ATOM_S:
            chars[0] = 'S';
            break;
        case ATOM_s:
            chars[0] = 's';
            break;
        case ATOM_P:
            chars[0] = 'P';
            break;
        case ATOM_p:
            chars[0] = 'p';
            break;
        case ATOM_F:
            chars[0] = 'F';
            break;
        case ATOM_Cl:
            chars[0] = 'C';
            chars[1] = 'l';
            break;
        case ATOM_Br:
            chars[0] = 'B';
            chars[1] = 'r';
            break;
        case ATOM_I:
            chars[0] = 'I';
            break;
        case ATOM_H:
            chars[0] = 'H';
            break;
        case ATOM_B:
            chars[0] = 'B';
            break;
        case ATOM_Si:
            chars[0] = 'S';
            chars[1] = 'i';
            break;
        case ATOM_As:
            chars[0] = 'A';
            chars[1] = 's';
            break;
        case ATOM_Se:
            chars[0] = 'S';
            chars[1] = 'e';
            break;
        default:
            chars[0] = 'X';
            break;
    }
}

// 键类型转SMILES字符
int BondTypeToSMILES(int bondType)
{
    switch (bondType)
    {
        case BOND_Single:
            return '-';
        case BOND_Double:
            return '=';
        case BOND_Triple:
            return '#';
        case BOND_Aromatic:
            return ':';
        default:
            return '-';
    }
}

// 生成电荷标记
void GenerateCharge(int charge, out int chars[3])
{
    chars[0] = 0;
    chars[1] = 0;
    chars[2] = 0;
    if (charge == 0)
        return;
    if (charge > 0)
    {
        chars[0] = '+';
        if (charge > 1)
            chars[1] = '0' + charge;
    }
    else
    {
        chars[0] = '-';
        if (charge < -1)
            chars[1] = '0' - charge;
    }
}

// 检查是否形成环结构
bool CheckRingFormation(float3 pos1, float3 pos2, float threshold)
{
    return distance(pos1, pos2) < threshold;
}

// 获取原子最大价键
int GetMaxValence(int atomType)
{
    switch (atomType)
    {
        case ATOM_C:
        case ATOM_c:
        case ATOM_Si:
            return MAX_VALENCE_C;
        case ATOM_N:
        case ATOM_n:
        case ATOM_As:
            return MAX_VALENCE_N;
        case ATOM_O:
        case ATOM_o:
        case ATOM_Se:
            return MAX_VALENCE_O;
        case ATOM_S:
        case ATOM_s:
            return MAX_VALENCE_S;
        case ATOM_F:
        case ATOM_Cl:
        case ATOM_Br:
        case ATOM_I:
            return 1;
        case ATOM_H:
            return MAX_VALENCE_H;
        case ATOM_B:
            return MAX_VALENCE_B;
        default:
            return 4;
    }
}

// 获取键级
float GetBondOrder(int bondType)
{
    switch (bondType)
    {
        case BOND_Single:
            return 1.0f;
        case BOND_Double:
            return 2.0f;
        case BOND_Triple:
            return 3.0f;
        case BOND_Aromatic:
            return 1.5f;
        default:
            return 1.0f;
    }
}

// 电荷合理性校验
int SanitizeCharge(int atomType, int charge)
{
    switch (atomType)
    {
        case ATOM_H:
        case ATOM_F:
        case ATOM_Cl:
        case ATOM_Br:
        case ATOM_I:
            return clamp(charge, -1, 1);
        case ATOM_C:
        case ATOM_c:
            return clamp(charge, -1, 1);
        case ATOM_N:
        case ATOM_n:
            return clamp(charge, -1, 2);
        case ATOM_O:
        case ATOM_o:
            return clamp(charge, -2, 1);
        case ATOM_S:
        case ATOM_s:
            return clamp(charge, -2, 2);
        default:
            return clamp(charge, -1, 1);
    }
}

// 键兼容性检查（v5.0增强：禁止饱和O/N接芳香键）
bool IsBondCompatible(int atomType, int bondType)
{
    if (atomType == ATOM_H || atomType == ATOM_F || atomType == ATOM_Cl ||
        atomType == ATOM_Br || atomType == ATOM_I)
    {
        return bondType == BOND_Single;
    }
    // 饱和O（ATOM_O）禁止双键/三键/芳香键，仅允许单键
    if (atomType == ATOM_O)
    {
        return bondType == BOND_Single;
    }
    // 饱和N（ATOM_N）禁止三键/芳香键
    if (atomType == ATOM_N && (bondType == BOND_Triple || bondType == BOND_Aromatic))
    {
        return false;
    }
    // 饱和碳（大写C）禁止芳香键
    if (atomType == ATOM_C && bondType == BOND_Aromatic)
    {
        return false;
    }
    return true;
}

// 判断是否为键符号
bool IsBondChar(int c)
{
    return c == '-' || c == '=' || c == '#' || c == ':';
}

// 字符右移（替代memmove）
void ShiftCharsRight(int startIdx, int shiftCount, inout int chars[SMILES_MAX_LENGTH], int currentLen)
{
    int endIdx = currentLen + shiftCount - 1;
    if (endIdx >= SMILES_MAX_LENGTH - 1)
        return;
    for (int i = currentLen - 1; i >= startIdx; i--)
    {
        chars[i + shiftCount] = chars[i];
    }
    for (int i = startIdx; i < startIdx + shiftCount; i++)
    {
        chars[i] = 0;
    }
}

// 合规化SMILES编码函数（v6.0修复：变量声明顺序优化，ringFormed先声明后使用）
void EncodeSMILES(int molIdx, int atomCount, in int atomTypes[MAX_ATOM_COUNT],
                 in float3 atomPositions[MAX_ATOM_COUNT], in int bondTypes[MAX_ATOM_COUNT],
                 in int charges[MAX_ATOM_COUNT], out int smilesChars[SMILES_MAX_LENGTH])
{
    // 初始化SMILES缓冲区
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
        smilesChars[i] = 0;
    
    int charIdx = 0;
    RingMarker ringMarkers[MAX_RING_COUNT];
    int ringCount = 0;
    int branchStack[MAX_BRANCH_DEPTH];
    int branchDepth = 0;
    float currentValence[MAX_ATOM_COUNT];
    bool ringNumberUsed[MAX_RING_COUNT + 1];
    bool isAromaticRing[MAX_ATOM_COUNT];
    bool isBufferFull = false;
    
    // 原子数校验
    if (atomCount == 0 || atomCount > MAX_ATOM_COUNT)
    {
        smilesChars[0] = 'C';
        smilesChars[1] = 0;
        return;
    }
    
    // 处理第一个原子
    int firstAtomType = atomTypes[0];
    int firstSanitizedCharge = SanitizeCharge(firstAtomType, charges[0]);
    int firstAtomChars[3];
    AtomTypeToSMILES(firstAtomType, firstAtomChars);
    
    if (!isBufferFull)
    {
        for (int i = 0; i < 3 && firstAtomChars[i] != 0 && charIdx < SMILES_MAX_LENGTH - 4; i++)
        {
            smilesChars[charIdx++] = firstAtomChars[i];
        }
        if (charIdx >= SMILES_MAX_LENGTH - 4)
            isBufferFull = true;
    }
    
    // 第一个原子电荷处理
    if (!isBufferFull && firstSanitizedCharge != 0)
    {
        int chargeChars[3];
        GenerateCharge(firstSanitizedCharge, chargeChars);
        int chargeLen = 0;
        while (chargeLen < 3 && chargeChars[chargeLen] != 0)
            chargeLen++;
        int shiftLen = 2 + chargeLen;
        ShiftCharsRight(0, shiftLen, smilesChars, charIdx);
        
        smilesChars[0] = '[';
        int writeIdx = 1;
        for (int i = 0; i < 3 && firstAtomChars[i] != 0; i++)
            smilesChars[writeIdx++] = firstAtomChars[i];
        for (int i = 0; i < chargeLen; i++)
            smilesChars[writeIdx++] = chargeChars[i];
        smilesChars[writeIdx++] = ']';
        charIdx = writeIdx;
        if (charIdx >= SMILES_MAX_LENGTH - 2)
            isBufferFull = true;
    }
    
    currentValence[0] = 0.0f;
    
    // 处理后续原子（v5.0优化：杂原子多环长碳链适配）
    for (int i = 1; i < atomCount && !isBufferFull; i++)
    {
        // 关闭未结束的支链
        while (branchDepth > 0 && !isBufferFull)
        {
            if (i <= branchStack[branchDepth - 1])
                break;
            smilesChars[charIdx++] = ')';
            branchDepth--;
            if (charIdx >= SMILES_MAX_LENGTH - 4)
                isBufferFull = true;
        }
        if (isBufferFull)
            break;
        
        // 化学键处理（价键强制合规）
        int prevAtomIdx = i - 1;
        int rawBondType = bondTypes[i];
        int currentAtomType = atomTypes[i];
        int currentMaxValence = GetMaxValence(currentAtomType);
        int prevMaxValence = GetMaxValence(atomTypes[prevAtomIdx]);
        
        // 键兼容性校验
        if (!IsBondCompatible(currentAtomType, rawBondType) || !IsBondCompatible(atomTypes[prevAtomIdx], rawBondType))
            rawBondType = BOND_Single;
        
        // 价键计算与强制合规
        float bondOrder = GetBondOrder(rawBondType);
        if (currentValence[prevAtomIdx] + bondOrder > prevMaxValence ||
            currentValence[i] + bondOrder > currentMaxValence)
        {
            // 价键超标时降级键类型
            if (rawBondType == BOND_Triple)
                rawBondType = BOND_Double;
            else if (rawBondType == BOND_Double)
                rawBondType = BOND_Single;
            bondOrder = GetBondOrder(rawBondType);
            
            // 仍超标则强制单键
            if (currentValence[prevAtomIdx] + bondOrder > prevMaxValence ||
                currentValence[i] + bondOrder > currentMaxValence)
            {
                rawBondType = BOND_Single;
                bondOrder = 1.0f;
            }
        }
        
        // ==================== v6.0修复：提前声明并初始化所有用到的变量 ====================
        // 声明ringFormed并初始化为false（解决先使用后声明问题）
        bool ringFormed = false;
        // 声明杂原子标记变量并初始化
        bool isCurrentHetero = (currentAtomType == ATOM_N || currentAtomType == ATOM_O || currentAtomType == ATOM_S);
        bool isPrevHetero = (atomTypes[prevAtomIdx] == ATOM_N || atomTypes[prevAtomIdx] == ATOM_O || atomTypes[prevAtomIdx] == ATOM_S);
        // 声明键符号相关变量并初始化
        bool nextIsBracket = false;
        bool nextIsRingNumber = false;
        // ==================================================================================
        
        // 写入键符号（v5.0优化：禁止键符号与括号相邻）
        if (rawBondType != BOND_Single)
        {
            // 预判下一个字符是否为括号/环编号/支链标记
            nextIsBracket = (branchDepth > 0 || ringFormed || (i + 1 < atomCount && branchStack[branchDepth] == i + 1));
            nextIsRingNumber = false;
            for (int k = 0; k < ringCount; k++)
            {
                if (ringMarkers[k].atomIndex == i)
                {
                    nextIsRingNumber = true;
                    break;
                }
            }
            
            // 括号/环编号前禁止非单键符号，强制使用单键
            if (!nextIsBracket && !nextIsRingNumber)
            {
                smilesChars[charIdx++] = BondTypeToSMILES(rawBondType);
            }
            else
            {
                rawBondType = BOND_Single;
            }
            
            if (charIdx >= SMILES_MAX_LENGTH - 4)
            {
                isBufferFull = true;
                break;
            }
        }
        
        // 支链生成（20%概率，适配杂原子支链）
        if (Random(uint2(molIdx + i, i)) < 0.2f && branchDepth < MAX_BRANCH_DEPTH &&
            i < atomCount - 2 && currentValence[i] + 1.0f <= currentMaxValence)
        {
            // 杂原子优先生成支链
            if (isCurrentHetero || Random(uint2(i, molIdx)) > 0.5f)
            {
                smilesChars[charIdx++] = '(';
                branchStack[branchDepth++] = i + RandomInt(uint2(i, molIdx), 1, 3); // 支链长度1-3
            }
            if (charIdx >= SMILES_MAX_LENGTH - 4)
            {
                isBufferFull = true;
                break;
            }
        }
        
        // 原子类型写入
        int currentAtomChars[3];
        AtomTypeToSMILES(currentAtomType, currentAtomChars);
        int atomLen = 0;
        while (atomLen < 3 && currentAtomChars[atomLen] != 0)
            atomLen++;
        for (int j = 0; j < atomLen && charIdx < SMILES_MAX_LENGTH - 4; j++)
            smilesChars[charIdx++] = currentAtomChars[j];
        if (charIdx >= SMILES_MAX_LENGTH - 4)
        {
            isBufferFull = true;
            break;
        }
        
        // 电荷处理
        int currentSanitizedCharge = SanitizeCharge(currentAtomType, charges[i]);
        if (currentSanitizedCharge != 0)
        {
            int chargeChars[3];
            GenerateCharge(currentSanitizedCharge, chargeChars);
            int chargeLen = 0;
            while (chargeLen < 3 && chargeChars[chargeLen] != 0)
                chargeLen++;
            int shiftLen = 2 + chargeLen;
            int atomStartIdx = charIdx - atomLen;
            ShiftCharsRight(atomStartIdx, shiftLen, smilesChars, charIdx);
            
            smilesChars[atomStartIdx] = '[';
            int chargeWriteIdx = atomStartIdx + atomLen;
            for (int j = 0; j < chargeLen; j++)
                smilesChars[chargeWriteIdx++] = chargeChars[j];
            smilesChars[chargeWriteIdx++] = ']';
            charIdx = chargeWriteIdx;
            if (charIdx >= SMILES_MAX_LENGTH - 2)
            {
                isBufferFull = true;
                break;
            }
        }
        
        // 环结构处理（v5.0优化：杂原子环优先编号、优先闭合）
        // 优先处理杂原子环（N/O/S）
        // 遍历候选环原子（优先杂原子）
        for (int j = (isCurrentHetero || isPrevHetero) ? 0 : i - 1; j < i && j >= 0 && !ringFormed; j++)
        {
            if (CheckRingFormation(atomPositions[i], atomPositions[j], 1.8f) &&
                ringCount < MAX_RING_COUNT && charIdx < SMILES_MAX_LENGTH - 2)
            {
                int existingRingNum = -1;
                // 查找已存在的环标记（优先杂原子环）
                for (int k = 0; k < ringCount; k++)
                {
                    bool isHeteroRing = (atomTypes[ringMarkers[k].atomIndex] == ATOM_N ||
                                         atomTypes[ringMarkers[k].atomIndex] == ATOM_O ||
                                         atomTypes[ringMarkers[k].atomIndex] == ATOM_S);
                    if (ringMarkers[k].atomIndex == j && IsRingNumberAvailable(ringMarkers[k].ringNumber, ringMarkers, ringCount) &&
                        (isHeteroRing || !isCurrentHetero))
                    {
                        existingRingNum = ringMarkers[k].ringNumber;
                        break;
                    }
                }
                
                if (existingRingNum != -1)
                {
                    // 闭合环（优先闭合杂原子环）
                    smilesChars[charIdx++] = '0' + existingRingNum;
                    float ringBondOrder = 1.0f;
                    // 环价键校验
                    if (currentValence[j] + ringBondOrder <= GetMaxValence(atomTypes[j]) &&
                        currentValence[i] + ringBondOrder <= currentMaxValence)
                    {
                        currentValence[j] += ringBondOrder;
                        currentValence[i] += ringBondOrder;
                    }
                    // 芳香环标记（仅芳香杂原子）
                    if ((atomTypes[j] == ATOM_n || atomTypes[j] == ATOM_o || atomTypes[j] == ATOM_s) &&
                        (currentAtomType == ATOM_n || currentAtomType == ATOM_o || currentAtomType == ATOM_s))
                    {
                        isAromaticRing[j] = true;
                        isAromaticRing[i] = true;
                    }
                    ringFormed = true;
                    break;
                }
                else
                {
                    // 新建环标记（v5.0优化：杂原子环优先分配1/2号）
                    int newRingNum = -1;
                    if (isCurrentHetero || (atomTypes[j] == ATOM_N || atomTypes[j] == ATOM_O || atomTypes[j] == ATOM_S))
                    {
                        // 杂原子环优先使用1/2号编号
                        for (int k = 1; k <= 2 && k <= MAX_RING_COUNT; k++)
                        {
                            if (!ringNumberUsed[k] && IsRingNumberAvailable(k, ringMarkers, ringCount))
                            {
                                newRingNum = k;
                                ringNumberUsed[k] = true;
                                break;
                            }
                        }
                    }
                    
                    // 普通环使用后续编号
                    if (newRingNum == -1)
                    {
                        for (int k = 3; k <= MAX_RING_COUNT; k++)
                        {
                            if (!ringNumberUsed[k] && IsRingNumberAvailable(k, ringMarkers, ringCount))
                            {
                                newRingNum = k;
                                ringNumberUsed[k] = true;
                                break;
                            }
                        }
                    }
                    
                    if (newRingNum != -1)
                    {
                        smilesChars[charIdx++] = '0' + newRingNum;
                        ringMarkers[ringCount].atomIndex = i;
                        ringMarkers[ringCount].ringNumber = newRingNum;
                        ringCount++;
                        ringFormed = true;
                        break;
                    }
                }
            }
        }
        
        // 芳香键处理（仅芳香杂原子）
        if (isAromaticRing[i] && !ringFormed && rawBondType == BOND_Single && charIdx < SMILES_MAX_LENGTH - 2)
        {
            if (Random(uint2(i, molIdx + i)) < 0.3f)
            {
                smilesChars[charIdx++] = ':';
                if (charIdx >= SMILES_MAX_LENGTH - 2)
                    isBufferFull = true;
            }
        }
        
        // 更新价键数并强制合规（v5.0增强：杂原子价键强化约束）
        currentValence[prevAtomIdx] += bondOrder;
        currentValence[i] += bondOrder;
        
        // 最终价键校验：通用约束
        currentValence[i] = min(currentValence[i], (float) currentMaxValence);
        currentValence[prevAtomIdx] = min(currentValence[prevAtomIdx], (float) prevMaxValence);
        
        // v5.0新增：N/O杂原子价键强化约束
        // 氧原子最大键级2
        if (currentAtomType == ATOM_O || currentAtomType == ATOM_o)
        {
            currentValence[i] = min(currentValence[i], 2.0f);
        }
        // 氮原子最大键级3
        if (currentAtomType == ATOM_N || currentAtomType == ATOM_n)
        {
            currentValence[i] = min(currentValence[i], 3.0f);
        }
        // 前驱原子为杂原子时同步约束
        if (atomTypes[prevAtomIdx] == ATOM_O || atomTypes[prevAtomIdx] == ATOM_o)
        {
            currentValence[prevAtomIdx] = min(currentValence[prevAtomIdx], 2.0f);
        }
        if (atomTypes[prevAtomIdx] == ATOM_N || atomTypes[prevAtomIdx] == ATOM_n)
        {
            currentValence[prevAtomIdx] = min(currentValence[prevAtomIdx], 3.0f);
        }
    }
    
    // 关闭所有未结束的支链
    while (branchDepth > 0 && !isBufferFull && charIdx < SMILES_MAX_LENGTH - 2)
    {
        smilesChars[charIdx++] = ')';
        branchDepth--;
    }
    
    // 清理末尾无效键符号
    while (charIdx > 0 && IsBondChar(smilesChars[charIdx - 1]))
        charIdx--;
    
    // 确保SMILES有效结尾
    smilesChars[charIdx] = 0;
    if (charIdx < 2)
    {
        smilesChars[0] = 'C';
        smilesChars[1] = 0;
    }
}

// 核心扩散函数（v5.0优化：杂原子生成概率提升、长碳链+杂原子分布优化）
[numthreads(64, 1, 1)]
void CSForwardDiffusion(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int molIdx = dispatchThreadID.x;
    if (molIdx >= batchSize)
        return;
    
    int totalMolIdx = molIdx + batchOffset;
    float3 activeCenter = activeCenterBuffer.xyz;
    float4 atomWeights = atomWeightBuffer;
    atomWeights = normalize(atomWeights);
    
    // 初始化分子参数（v5.0优化：适配含杂原子长碳链，原子数≥18）
    int atomCount = (int) lerp(18, maxAtoms, Random(uint2(molIdx, 0)));
    int atomTypes[MAX_ATOM_COUNT];
    float3 atomPositions[MAX_ATOM_COUNT];
    int bondTypes[MAX_ATOM_COUNT];
    int charges[MAX_ATOM_COUNT];
    float totalFeatureScore = 0.0f;
    
    // 初始化Debug Buffer
    for (int a = 0; a < MAX_ATOM_COUNT; a++)
    {
        matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = 0.0f;
    }
    
    // 前向扩散主循环
    for (int t = 0; t < timesteps; t++)
    {
        float alphaCumprod = alphaCumprodBuffer[t];
        float beta = betaBuffer[t];
        
        for (int a = 0; a < atomCount; a++)
        {
            // 提取热力图原始通道值
            float atomTypeR, chargeG, hydrophobicB, hBondA;
            
            if (t == 0)
            {
                // 初始位置：贴近活性中心（杂原子长碳链集中分布）
                atomPositions[a] = activeCenter + float3(
                    RandomRange(uint2(totalMolIdx, a), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(a, totalMolIdx), -heatmapSize * 0.4f, heatmapSize * 0.4f),
                    RandomRange(uint2(totalMolIdx + a, a), -heatmapSize * 0.4f, heatmapSize * 0.4f)
                );
                
                // 原子类型：热力图r通道直接驱动 + v5.0杂原子概率提升
                GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter,
                                            atomTypeR, chargeG, hydrophobicB, hBondA);
                atomTypes[a] = HeatmapRToAtomType(atomTypeR);
                
                // v5.0新增：提升N/O杂原子生成概率（15%）
                float heteroRand = Random(uint2(a + 100, molIdx));
                if (heteroRand < 0.15f && a > 3 && a < atomCount - 3)
                {
                    // 优先在碳链中间插入N/O杂原子
                    int heteroTypes[] = { ATOM_N, ATOM_O };
                    atomTypes[a] = heteroTypes[RandomInt(uint2(a + 200, molIdx), 0, 1)];
                }
                
                // 禁止连续相同原子超过3个（含杂原子）
                if (a >= MAX_CONSECUTIVE_ATOMS)
                {
                    bool isConsecutive = true;
                    for (int k = 1; k <= MAX_CONSECUTIVE_ATOMS; k++)
                    {
                        if (atomTypes[a] != atomTypes[a - k])
                        {
                            isConsecutive = false;
                            break;
                        }
                    }
                    if (isConsecutive)
                    {
                        // 替换为杂原子或H
                        int altTypes[] = { ATOM_H, ATOM_O, ATOM_N, ATOM_c };
                        atomTypes[a] = altTypes[RandomInt(uint2(a, molIdx), 0, 3)];
                    }
                }
                
                // 电荷：热力图g通道直接驱动（非0概率≤10%）
                int rawCharge = (int) round(chargeG);
                // 额外控制非0电荷概率≤10%
                float chargeRand = Random(uint2(a + t, totalMolIdx));
                if (chargeRand > 0.9f)
                {
                    charges[a] = SanitizeCharge(atomTypes[a], rawCharge);
                }
                else
                {
                    charges[a] = 0;
                }
                
                // 键类型：热力图驱动+三键概率≤5% + v5.0杂原子键约束
                if (a == 0)
                {
                    bondTypes[a] = BOND_Single;
                }
                else
                {
                    // 杂原子优先单键
                    bool isHetero = (atomTypes[a] == ATOM_N || atomTypes[a] == ATOM_O || atomTypes[a] == ATOM_S);
                    if (isHetero || hBondA > 0.5f)
                    {
                        bondTypes[a] = BOND_Single;
                    }
                    // 疏水性高→芳香键/双键（仅非杂原子）
                    else if (hydrophobicB > 0.7f)
                    {
                        bondTypes[a] = Random(uint2(a, t)) < 0.5f ? BOND_Aromatic : BOND_Double;
                    }
                    // 三键概率≤5%（仅碳-碳键）
                    else if (Random(uint2(a, t)) < 0.05f && atomTypes[a] == ATOM_C && atomTypes[a - 1] == ATOM_C)
                    {
                        bondTypes[a] = BOND_Triple;
                    }
                    else
                    {
                        bondTypes[a] = BOND_Single;
                    }
                    // 键兼容性校验（强化杂原子键约束）
                    if (!IsBondCompatible(atomTypes[a], bondTypes[a]))
                    {
                        bondTypes[a] = BOND_Single;
                    }
                }
            }
            else
            {
                // 扩散噪声（v5.0优化：杂原子区域噪声降低）
                bool isHetero = (atomTypes[a] == ATOM_N || atomTypes[a] == ATOM_O || atomTypes[a] == ATOM_S);
                float noiseScale = isHetero ? 0.5f : 1.0f; // 杂原子区域噪声减半
                float3 noise = float3(
                    RandomRange(uint2(totalMolIdx + a, t), -1.0f, 1.0f) * noiseScale,
                    RandomRange(uint2(a, totalMolIdx + t), -1.0f, 1.0f) * noiseScale,
                    RandomRange(uint2(totalMolIdx + a + t, a), -1.0f, 1.0f) * noiseScale
                );
                
                // 基础扩散公式
                atomPositions[a] = sqrt(alphaCumprod) * atomPositions[a] + sqrt(1 - alphaCumprod) * noise;
                
                // 提取热力图特征并更新参数
                float featureScore = GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter,
                                                                 atomTypeR, chargeG, hydrophobicB, hBondA);
                totalFeatureScore += featureScore;
                
                // 特征分过低→拉回活性中心
                if (featureScore < minFeatureScore)
                {
                    atomPositions[a] = lerp(atomPositions[a], activeCenter, 0.2f);
                    featureScore = GetProteinFeatureConstraint3D(totalMolIdx, atomPositions[a], activeCenter,
                                                                 atomTypeR, chargeG, hydrophobicB, hBondA);
                }
                
                // 实时更新原子类型（禁止连续重复+杂原子优先）
                int newAtomType = HeatmapRToAtomType(atomTypeR);
                
                // 检查连续重复
                bool isConsecutive = true;
                if (a >= MAX_CONSECUTIVE_ATOMS)
                {
                    for (int k = 1; k <= MAX_CONSECUTIVE_ATOMS; k++)
                    {
                        if (newAtomType != atomTypes[a - k])
                        {
                            isConsecutive = false;
                            break;
                        }
                    }
                }
                else
                {
                    isConsecutive = false;
                }
                
                // 价键允许且非连续重复时更新原子类型
                float currentBondOrder = GetBondOrder(bondTypes[a]);
                int currentMaxValence = GetMaxValence(atomTypes[a]);
                int newMaxValence = GetMaxValence(newAtomType);
                if (currentBondOrder <= newMaxValence && !isConsecutive)
                {
                    // v5.0优化：保留已生成的杂原子，不被热力图覆盖
                    bool isCurrentHetero = (atomTypes[a] == ATOM_N || atomTypes[a] == ATOM_O || atomTypes[a] == ATOM_S);
                    bool isNewHetero = (newAtomType == ATOM_N || newAtomType == ATOM_O || newAtomType == ATOM_S);
                    if (!isCurrentHetero || isNewHetero)
                    {
                        atomTypes[a] = newAtomType;
                    }
                }
                
                // 实时更新电荷
                int newCharge = (int) round(chargeG);
                charges[a] = SanitizeCharge(atomTypes[a], newCharge);
                
                // 实时更新键类型（强化杂原子键约束）
                isHetero = (atomTypes[a] == ATOM_N || atomTypes[a] == ATOM_O || atomTypes[a] == ATOM_S);
                if (isHetero || hBondA > 0.5f)
                {
                    bondTypes[a] = BOND_Single;
                }
                else if (hydrophobicB > 0.7f && atomTypes[a] == ATOM_c)
                {
                    bondTypes[a] = BOND_Aromatic;
                }
                
                // 更新Debug Buffer
                if (featureScore > matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a])
                {
                    matchScoreDebugBuffer[molIdx * MAX_ATOM_COUNT + a] = featureScore;
                }
            }
        }
    }
    
    // 过滤无效分子
    float avgFeatureScore = totalFeatureScore / (atomCount * timesteps);
    if (avgFeatureScore < minFeatureScore)
        return;
    
    // 编码为合规SMILES（含杂原子多环长碳链）
    int smilesChars[SMILES_MAX_LENGTH];
    EncodeSMILES(molIdx, atomCount, atomTypes, atomPositions, bondTypes, charges, smilesChars);
    
    // 写入输出
    for (int i = 0; i < SMILES_MAX_LENGTH; i++)
    {
        int charVal = smilesChars[i];
        smilesOutputBuffer[molIdx * SMILES_MAX_LENGTH + i] = charVal;
        float r = (float) charVal / 255.0f;
        smilesOutputTexture[int2(i, molIdx)] = float4(r, 0, 0, 1);
    }
}